minispade.register('ember-inflector/system/inflector', "(function() {var BLANK_REGEX = /^\\s*$/;\n\nfunction loadUncountable(rules, uncountable) {\n  for (var i = 0, length = uncountable.length; i < length; i++) {\n    rules.uncountable[uncountable[i]] = true;\n  }\n}\n\nfunction loadIrregular(rules, irregularPairs) {\n  var pair;\n\n  for (var i = 0, length = irregularPairs.length; i < length; i++) {\n    pair = irregularPairs[i];\n\n    rules.irregular[pair[0]] = pair[1];\n    rules.irregularInverse[pair[1]] = pair[0];\n  }\n}\n\n/**\n  Inflector.Ember provides a mechanism for supplying inflection rules for your\n  application. Ember includes a default set of inflection rules, and provides an\n  API for providing additional rules.\n\n  Examples:\n\n  Creating an inflector with no rules.\n\n  ```js\n  var inflector = new Ember.Inflector();\n  ```\n\n  Creating an inflector with the default ember ruleset.\n\n  ```js\n  var inflector = new Ember.Inflector(Ember.Inflector.defaultRules);\n\n  inflector.pluralize('cow') //=> 'kine'\n  inflector.singularize('kine') //=> 'cow'\n  ```\n\n  Creating an inflector and adding rules later.\n\n  ```javascript\n  var inflector = Ember.Inflector.inflector;\n\n  inflector.pluralize('advice') // => 'advices'\n  inflector.uncountable('advice');\n  inflector.pluralize('advice') // => 'advice'\n\n  inflector.pluralize('formula') // => 'formulas'\n  inflector.irregular('formula', 'formulae');\n  inflector.pluralize('formula') // => 'formulae'\n\n  // you would not need to add these as they are the default rules\n  inflector.plural(/$/, 's');\n  inflector.singular(/s$/i, '');\n  ```\n\n  Creating an inflector with a nondefault ruleset.\n\n  ```javascript\n  var rules = {\n    plurals:  [ /$/, 's' ],\n    singular: [ /\\s$/, '' ],\n    irregularPairs: [\n      [ 'cow', 'kine' ]\n    ],\n    uncountable: [ 'fish' ]\n  };\n\n  var inflector = new Ember.Inflector(rules);\n  ```\n\n  @class Inflector\n  @namespace Ember\n*/\nfunction Inflector(ruleSet) {\n  ruleSet = ruleSet || {};\n  ruleSet.uncountable = ruleSet.uncountable || {};\n  ruleSet.irregularPairs= ruleSet.irregularPairs|| {};\n\n  var rules = this.rules = {\n    plurals:  ruleSet.plurals || [],\n    singular: ruleSet.singular || [],\n    irregular: {},\n    irregularInverse: {},\n    uncountable: {}\n  };\n\n  loadUncountable(rules, ruleSet.uncountable);\n  loadIrregular(rules, ruleSet.irregularPairs);\n}\n\nInflector.prototype = {\n  /**\n    @method plural\n    @param {RegExp} regex\n    @param {String} string\n  */\n  plural: function(regex, string) {\n    this.rules.plurals.push([regex, string]);\n  },\n\n  /**\n    @method singular\n    @param {RegExp} regex\n    @param {String} string\n  */\n  singular: function(regex, string) {\n    this.rules.singular.push([regex, string]);\n  },\n\n  /**\n    @method uncountable\n    @param {String} regex\n  */\n  uncountable: function(string) {\n    loadUncountable(this.rules, [string]);\n  },\n\n  /**\n    @method irregular\n    @param {String} singular\n    @param {String} plural\n  */\n  irregular: function (singular, plural) {\n    loadIrregular(this.rules, [[singular, plural]]);\n  },\n\n  /**\n    @method pluralize\n    @param {String} word\n  */\n  pluralize: function(word) {\n    return this.inflect(word, this.rules.plurals, this.rules.irregular);\n  },\n\n  /**\n    @method singularize\n    @param {String} word\n  */\n  singularize: function(word) {\n    return this.inflect(word, this.rules.singular,  this.rules.irregularInverse);\n  },\n\n  /**\n    @protected\n\n    @method inflect\n    @param {String} word\n    @param {Object} typeRules\n    @param {Object} irregular\n  */\n  inflect: function(word, typeRules, irregular) {\n    var inflection, substitution, result, lowercase, isBlank,\n    isUncountable, isIrregular, isIrregularInverse, rule;\n\n    isBlank = BLANK_REGEX.test(word);\n\n    if (isBlank) {\n      return word;\n    }\n\n    lowercase = word.toLowerCase();\n\n    isUncountable = this.rules.uncountable[lowercase];\n\n    if (isUncountable) {\n      return word;\n    }\n\n    isIrregular = irregular && irregular[lowercase];\n\n    if (isIrregular) {\n      return isIrregular;\n    }\n\n    for (var i = typeRules.length, min = 0; i > min; i--) {\n       inflection = typeRules[i-1];\n       rule = inflection[0];\n\n      if (rule.test(word)) {\n        break;\n      }\n    }\n\n    inflection = inflection || [];\n\n    rule = inflection[0];\n    substitution = inflection[1];\n\n    result = word.replace(rule, substitution);\n\n    return result;\n  }\n};\n\nEmber.Inflector = Inflector;\n\n})();\n//@ sourceURL=ember-inflector/system/inflector");