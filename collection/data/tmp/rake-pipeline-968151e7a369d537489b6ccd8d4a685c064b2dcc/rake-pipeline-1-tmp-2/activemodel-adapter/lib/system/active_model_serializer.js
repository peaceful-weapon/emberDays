minispade.register('activemodel-adapter/system/active_model_serializer', "(function() {minispade.require('ember-data/serializers/rest_serializer');\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get;\nvar forEach = Ember.EnumerableUtils.forEach;\n\nDS.ActiveModelSerializer = DS.RESTSerializer.extend({\n  // SERIALIZE\n\n  /**\n    Converts camelcased attributes to underscored when serializing.\n\n    @method keyForAttribute\n    @param {String} attribute\n    @returns String\n  */\n  keyForAttribute: function(attr) {\n    return Ember.String.decamelize(attr);\n  },\n\n  /**\n    Underscores relationship names and appends \"_id\" or \"_ids\" when serializing\n    relationship keys.\n\n    @method keyForRelationship\n    @param {String} key\n    @param {String} kind\n    @returns String\n  */\n  keyForRelationship: function(key, kind) {\n    key = Ember.String.decamelize(key);\n    if (kind === \"belongsTo\") {\n      return key + \"_id\";\n    } else if (kind === \"hasMany\") {\n      return Ember.String.singularize(key) + \"_ids\";\n    } else {\n      return key;\n    }\n  },\n\n  /**\n    Serialize has-may relationship when it is configured as embedded objects.\n\n    @method serializeHasMany\n  */\n  serializeHasMany: function(record, json, relationship) {\n    var key   = relationship.key,\n        attrs = get(this, 'attrs'),\n        embed = attrs && attrs[key] && attrs[key].embedded === 'always';\n\n    if (embed) {\n      json[this.keyForAttribute(key)] = get(record, key).map(function(relation) {\n        var data = relation.serialize(),\n            primaryKey = get(this, 'primaryKey');\n\n        data[primaryKey] = get(relation, primaryKey);\n\n        return data;\n      }, this);\n    }\n  },\n\n  /**\n    Underscores the JSON root keys when serializing.\n\n    @method serializeIntoHash\n    @param {Object} hash\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @param {Object} options\n  */\n  serializeIntoHash: function(data, type, record, options) {\n    var root = Ember.String.decamelize(type.typeKey);\n    data[root] = this.serialize(record, options);\n  },\n\n  /**\n    Serializes a polymorphic type as a fully capitalized model name.\n\n    @method serializePolymorphicType\n    @param {DS.Model} record\n    @param {Object} json\n    @param relationship\n  */\n  serializePolymorphicType: function(record, json, relationship) {\n    var key = relationship.key,\n        belongsTo = get(record, key);\n    key = this.keyForAttribute(key);\n    json[key + \"_type\"] = Ember.String.capitalize(belongsTo.constructor.typeKey);\n  },\n\n  // EXTRACT\n\n  /**\n    Extracts the model typeKey from underscored root objects.\n\n    @method typeForRoot\n    @param {String} root\n    @returns String the model's typeKey\n  */\n  typeForRoot: function(root) {\n    var camelized = Ember.String.camelize(root);\n    return Ember.String.singularize(camelized);\n  },\n\n  /**\n    Normalize the polymorphic type from the JSON.\n\n    Normalize:\n    ```js\n      {\n        id: \"1\"\n        minion: { type: \"evil_minion\", id: \"12\"}\n      }\n    ```\n\n    To:\n    ```js\n      {\n        id: \"1\"\n        minion: { type: \"evilMinion\", id: \"12\"}\n      }\n    ```\n\n    @method normalizeRelationships\n    @private\n  */\n  normalizeRelationships: function(type, hash) {\n    var payloadKey, payload;\n\n    if (this.keyForRelationship) {\n      type.eachRelationship(function(key, relationship) {\n        if (relationship.options.polymorphic) {\n          payloadKey = this.keyForAttribute(key);\n          payload = hash[payloadKey];\n          if (payload && payload.type) {\n            payload.type = this.typeForRoot(payload.type);\n          } else if (payload && relationship.kind === \"hasMany\") {\n            var self = this;\n            forEach(payload, function(single) {\n              single.type = self.typeForRoot(single.type);\n            });\n          }\n        } else {\n          payloadKey = this.keyForRelationship(key, relationship.kind);\n          payload = hash[payloadKey];\n        }\n\n        hash[key] = payload;\n\n        if (key !== payloadKey) {\n          delete hash[payloadKey];\n        }\n      }, this);\n    }\n  },\n\n  extractSingle: function(store, primaryType, payload, recordId, requestType) {\n    var root = this.keyForAttribute(primaryType.typeKey),\n        partial = payload[root];\n\n    updatePayloadWithEmbedded(store, this, primaryType, partial, payload);\n\n    return this._super(store, primaryType, payload, recordId, requestType);\n  },\n\n  extractArray: function(store, type, payload) {\n    var root = this.keyForAttribute(type.typeKey),\n        partials = payload[Ember.String.pluralize(root)];\n\n    forEach(partials, function(partial) {\n      updatePayloadWithEmbedded(store, this, type, partial, payload);\n    }, this);\n\n    return this._super(store, type, payload);\n  }\n});\n\nfunction updatePayloadWithEmbedded(store, serializer, type, partial, payload) {\n  var attrs = get(serializer, 'attrs');\n\n  if (!attrs) {\n    return;\n  }\n\n  type.eachRelationship(function(key, relationship) {\n    var expandedKey, embeddedTypeKey, attribute, ids,\n        config = attrs[key],\n        serializer = store.serializerFor(relationship.type.typeKey),\n        primaryKey = get(serializer, \"primaryKey\");\n\n    if (relationship.kind !== \"hasMany\") {\n      return;\n    }\n\n    if (config && (config.embedded === 'always' || config.embedded === 'load')) {\n      // underscore forces the embedded records to be side loaded.\n      // it is needed when main type === relationship.type\n      embeddedTypeKey = '_' + Ember.String.pluralize(relationship.type.typeKey);\n      expandedKey = this.keyForRelationship(key, relationship.kind);\n      attribute  = this.keyForAttribute(key);\n      ids = [];\n\n      if (!partial[attribute]) {\n        return;\n      }\n\n      payload[embeddedTypeKey] = payload[embeddedTypeKey] || [];\n\n      forEach(partial[attribute], function(data) {\n        var embeddedType = store.modelFor(relationship.type.typeKey);\n        updatePayloadWithEmbedded(store, serializer, embeddedType, data, payload);\n        ids.push(data[primaryKey]);\n        payload[embeddedTypeKey].push(data);\n      });\n\n      partial[expandedKey] = ids;\n      delete partial[attribute];\n    }\n  }, serializer);\n}\n\n})();\n//@ sourceURL=activemodel-adapter/system/active_model_serializer");