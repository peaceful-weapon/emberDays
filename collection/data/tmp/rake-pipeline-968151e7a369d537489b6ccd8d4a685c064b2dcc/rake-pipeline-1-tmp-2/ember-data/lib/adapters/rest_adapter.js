minispade.register('ember-data/adapters/rest_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require('ember-data/system/adapter');\nminispade.require('ember-data/serializers/rest_serializer');\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.ArrayPolyfills.forEach;\n\n/**\n  The REST adapter allows your store to communicate with an HTTP server by\n  transmitting JSON via XHR. Most Ember.js apps that consume a JSON API\n  should use the REST adapter.\n\n  This adapter is designed around the idea that the JSON exchanged with\n  the server should be conventional.\n\n  ## JSON Structure\n\n  The REST adapter expects the JSON returned from your server to follow\n  these conventions.\n\n  ### Object Root\n\n  The JSON payload should be an object that contains the record inside a\n  root property. For example, in response to a `GET` request for\n  `/posts/1`, the JSON should look like this:\n\n  ```js\n  {\n    \"post\": {\n      title: \"I'm Running to Reform the W3C's Tag\",\n      author: \"Yehuda Katz\"\n    }\n  }\n  ```\n\n  ### Conventional Names\n\n  Attribute names in your JSON payload should be the camelCased versions of\n  the attributes in your Ember.js models.\n\n  For example, if you have a `Person` model:\n\n  ```js\n  App.Person = DS.Model.extend({\n    firstName: DS.attr('string'),\n    lastName: DS.attr('string'),\n    occupation: DS.attr('string')\n  });\n  ```\n\n  The JSON returned should look like this:\n\n  ```js\n  {\n    \"person\": {\n      \"firstName\": \"Barack\",\n      \"lastName\": \"Obama\",\n      \"occupation\": \"President\"\n    }\n  }\n  ```\n\n  ## Customization\n\n  ### Endpoint path customization\n\n  Endpoint paths can be prefixed with a `namespace` by setting the namespace\n  property on the adapter:\n\n  ```js\n  DS.RESTAdapter.reopen({\n    namespace: 'api/1'\n  });\n  ```\n  Requests for `App.Person` would now target `/api/1/people/1`.\n\n  ### Host customization\n\n  An adapter can target other hosts by setting the `host` property.\n\n  ```js\n  DS.RESTAdapter.reopen({\n    host: 'https://api.example.com'\n  });\n  ```\n\n  ### Headers customization\n\n  Some APIs require HTTP headers, e.g. to provide an API key. An array of\n  headers can be added to the adapter which are passed with every request:\n\n  ```js\n  DS.RESTAdapter.reopen({\n    headers: {\n      \"API_KEY\": \"secret key\",\n      \"ANOTHER_HEADER\": \"Some header value\"\n    }\n  });\n  ```\n\n  @class RESTAdapter\n  @constructor\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.RESTAdapter = DS.Adapter.extend({\n  defaultSerializer: '_rest',\n\n  /**\n    Called by the store in order to fetch the JSON for a given\n    type and ID.\n\n    The `find` method makes an Ajax request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    This method performs an HTTP `GET` request with the id provided as part of the querystring. \n\n    @method find\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @returns Promise\n  */\n  find: function(store, type, id) {\n    return this.ajax(this.buildURL(type.typeKey, id), 'GET');\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for all\n    of the records for a given type.\n\n    The `findAll` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method findAll\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {String} sinceToken\n    @returns Promise\n  */\n  findAll: function(store, type, sinceToken) {\n    var query;\n\n    if (sinceToken) {\n      query = { since: sinceToken };\n    }\n\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: query });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the records that match a particular query.\n\n    The `findQuery` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    The `query` argument is a simple JavaScript object that will be passed directly\n    to the server as parameters.\n\n    @method findQuery\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Object} query\n    @returns Promise\n  */\n  findQuery: function(store, type, query) {\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: query });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a has-many relationship that were originally\n    specified as IDs.\n\n    For example, if the original payload looks like:\n\n    ```js\n    {\n      \"id\": 1,\n      \"title\": \"Rails is omakase\",\n      \"comments\": [ 1, 2, 3 ]\n    }\n    ```\n\n    The IDs will be passed as a URL-encoded Array of IDs, in this form:\n\n    ```\n    ids[]=1&ids[]=2&ids[]=3\n    ```\n\n    Many servers, such as Rails and PHP, will automatically convert this URL-encoded array\n    into an Array for you on the server-side. If you want to encode the\n    IDs, differently, just override this (one-line) method.\n\n    The `findMany` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a\n    promise for the resulting payload.\n\n    @method findMany\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {Array<String>} ids\n    @returns Promise\n  */\n  findMany: function(store, type, ids, owner) {\n    return this.ajax(this.buildURL(type.typeKey), 'GET', { data: { ids: ids } });\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a has-many relationship that were originally\n    specified as a URL (inside of `links`).\n\n    For example, if your original payload looks like this:\n\n    ```js\n    {\n      \"post\": {\n        \"id\": 1,\n        \"title\": \"Rails is omakase\",\n        \"links\": { \"comments\": \"/posts/1/comments\" }\n      }\n    }\n    ```\n\n    This method will be called with the parent record and `/posts/1/comments`.\n\n    The `findHasMany` method will make an Ajax (HTTP GET) request to the originally specified URL.\n    If the URL is host-relative (starting with a single slash), the\n    request will use the host specified on the adapter (if any).\n\n    @method findHasMany\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {DS.Model} record\n    @param {String} url\n    @returns Promise\n  */\n  findHasMany: function(store, record, url) {\n    var host = get(this, 'host'),\n        id   = get(record, 'id'),\n        type = record.constructor.typeKey;\n\n    if (host && url.charAt(0) === '/' && url.charAt(1) !== '/') {\n      url = host + url;\n    }\n\n    return this.ajax(this.urlPrefix(url, this.buildURL(type, id)), 'GET');\n  },\n\n  /**\n    Called by the store in order to fetch a JSON array for\n    the unloaded records in a belongs-to relationship that were originally\n    specified as a URL (inside of `links`).\n\n    For example, if your original payload looks like this:\n\n    ```js\n    {\n      \"person\": {\n        \"id\": 1,\n        \"name\": \"Tom Dale\",\n        \"links\": { \"group\": \"/people/1/group\" }\n      }\n    }\n    ```\n\n    This method will be called with the parent record and `/people/1/group`.\n\n    The `findBelongsTo` method will make an Ajax (HTTP GET) request to the originally specified URL.\n\n    @method findBelongsTo\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @param {DS.Store} store\n    @param {DS.Model} record\n    @param {String} url\n    @returns Promise\n  */\n  findBelongsTo: function(store, record, url) {\n    var id   = get(record, 'id'),\n        type = record.constructor.typeKey;\n\n    return this.ajax(this.urlPrefix(url, this.buildURL(type, id)), 'GET');\n  },\n\n  /**\n    Called by the store when a newly created record is\n    saved via the `save` method on a model record instance.\n\n    The `createRecord` method serializes the record and makes an Ajax (HTTP POST) request \n    to a URL computed by `buildURL`.\n\n    See `serialize` for information on how to customize the serialized form\n    of a record.\n\n    @method createRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  createRecord: function(store, type, record) {\n    var data = {};\n    var serializer = store.serializerFor(type.typeKey);\n\n    serializer.serializeIntoHash(data, type, record, { includeId: true });\n\n    return this.ajax(this.buildURL(type.typeKey), \"POST\", { data: data });\n  },\n\n  /**\n    Called by the store when an existing record is saved \n    via the `save` method on a model record instance.\n    \n    The `updateRecord` method serializes the record and makes an Ajax (HTTP PUT) request \n    to a URL computed by `buildURL`.\n\n    See `serialize` for information on how to customize the serialized form\n    of a record.\n\n    @method updateRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  updateRecord: function(store, type, record) {\n    var data = {};\n    var serializer = store.serializerFor(type.typeKey);\n\n    serializer.serializeIntoHash(data, type, record);\n\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type.typeKey, id), \"PUT\", { data: data });\n  },\n\n  /**\n    Called by the store when a record is deleted.\n\n    The `deleteRecord` method  makes an Ajax (HTTP DELETE) request to a URL computed by `buildURL`.\n\n    @method deleteRecord\n    @see RESTAdapter/buildURL\n    @see RESTAdapter/ajax\n    @see RESTAdapter/serialize\n    @param {DS.Store} store\n    @param {subclass of DS.Model} type\n    @param {DS.Model} record\n    @returns Promise\n  */\n  deleteRecord: function(store, type, record) {\n    var id = get(record, 'id');\n\n    return this.ajax(this.buildURL(type.typeKey, id), \"DELETE\");\n  },\n\n  /**\n    Builds a URL for a given type and optional ID.\n\n    By default, it pluralizes the type's name (for example,\n    'post' becomes 'posts' and 'person' becomes 'people').\n\n    If an ID is specified, it adds the ID to the path generated\n    for the type, separated by a `/`.\n\n    @method buildURL\n    @param {String} type\n    @param {String} id\n    @returns String\n  */\n  buildURL: function(type, id) {\n    var url = [],\n        host = get(this, 'host'),\n        prefix = this.urlPrefix();\n\n    if (type) { url.push(this.pathForType(type)); }\n    if (id) { url.push(id); }\n\n    if (prefix) { url.unshift(prefix); }\n\n    url = url.join('/');\n    if (!host && url) { url = '/' + url; }\n\n    return url;\n  },\n\n  urlPrefix: function(path, parentURL) {\n    var host = get(this, 'host'),\n        namespace = get(this, 'namespace'),\n        url = [];\n\n    if (path) {\n      // Absolute path\n      if (path.charAt(0) === '/') {\n        if (host) {\n          path = path.slice(1);\n          url.push(host);\n        }\n      // Relative path\n      } else if (!/^http(s)?:\\/\\//.test(path)) {\n        url.push(parentURL);\n      }\n    } else {\n      if (host) { url.push(host); }\n      if (namespace) { url.push(namespace); }\n    }\n\n    if (path) {\n      url.push(path);\n    }\n\n    return url.join('/');\n  },\n\n  /**\n    Determines the pathname for a given type.\n\n    By default, it pluralizes the type's name (for example,\n    'post' becomes 'posts' and 'person' becomes 'people').\n\n    ### Pathname customization\n\n    For example if you have an object LineItem with an\n    endpoint of \"/line_items/\".\n\n    ```js\n    DS.RESTAdapter.reopen({\n      pathForType: function(type) {\n        var decamelized = Ember.String.decamelize(type);\n        return Ember.String.pluralize(decamelized);\n      };\n    });\n    ```\n\n    @method pathForType\n    @param {String} type\n    @returns String\n  **/\n  pathForType: function(type) {\n    return Ember.String.pluralize(type);\n  },\n\n  /**\n    Takes an ajax response, and returns a relavant error.\n\n    By default, the `ajaxError` method has the following behavior:\n\n    * It simply returns the ajax response (jqXHR).\n\n    @method ajaxError\n    @param  jqXHR\n  */\n  ajaxError: function(jqXHR) {\n    if (jqXHR) {\n      jqXHR.then = null;\n    }\n\n    return jqXHR;\n  },\n\n  /**\n    Takes a URL, an HTTP method and a hash of data, and makes an\n    HTTP request.\n\n    When the server responds with a payload, Ember Data will call into `extractSingle`\n    or `extractArray` (depending on whether the original query was for one record or\n    many records).\n\n    By default, `ajax` method has the following behavior:\n\n    * It sets the response `dataType` to `\"json\"`\n    * If the HTTP method is not `\"GET\"`, it sets the `Content-Type` to be\n      `application/json; charset=utf-8`\n    * If the HTTP method is not `\"GET\"`, it stringifies the data passed in. The\n      data is the serialized record in the case of a save.\n    * Registers success and failure handlers.\n\n    @method ajax\n    @private\n    @param  url\n    @param  type\n    @param  hash\n  */\n  ajax: function(url, type, hash) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n      hash = adapter.ajaxOptions(url, type, hash);\n\n      hash.success = function(json) {\n        Ember.run(null, resolve, json);\n      };\n\n      hash.error = function(jqXHR, textStatus, errorThrown) {\n        Ember.run(null, reject, adapter.ajaxError(jqXHR));\n      };\n\n      Ember.$.ajax(hash);\n    });\n  },\n\n  ajaxOptions: function(url, type, hash) {\n    hash = hash || {};\n    hash.url = url;\n    hash.type = type;\n    hash.dataType = 'json';\n    hash.context = this;\n\n    if (hash.data && type !== 'GET') {\n      hash.contentType = 'application/json; charset=utf-8';\n      hash.data = JSON.stringify(hash.data);\n    }\n\n    if (this.headers !== undefined) {\n      var headers = this.headers;\n      hash.beforeSend = function (xhr) {\n        forEach.call(Ember.keys(headers), function(key) {\n          xhr.setRequestHeader(key, headers[key]);\n        });\n      };\n    }\n\n\n    return hash;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/adapters/rest_adapter");