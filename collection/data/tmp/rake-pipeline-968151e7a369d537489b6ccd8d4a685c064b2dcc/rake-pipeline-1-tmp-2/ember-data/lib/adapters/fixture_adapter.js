minispade.register('ember-data/adapters/fixture_adapter', "(function() {minispade.require(\"ember-data/core\");\nminispade.require(\"ember-data/system/adapter\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, fmt = Ember.String.fmt,\n    indexOf = Ember.EnumerableUtils.indexOf;\n\nvar counter = 0;\n\n/**\n  `DS.FixtureAdapter` is an adapter that loads records from memory.\n  Its primarily used for development and testing. You can also use\n  `DS.FixtureAdapter` while working on the API but are not ready to\n  integrate yet. It is a fully functioning adapter. All CRUD methods\n  are implemented. You can also implement query logic that a remote\n  system would do. Its possible to do develop your entire application\n  with `DS.FixtureAdapter`.\n\n  @class FixtureAdapter\n  @namespace DS\n  @extends DS.Adapter\n*/\nDS.FixtureAdapter = DS.Adapter.extend({\n  // by default, fixtures are already in normalized form\n  serializer: null,\n\n  simulateRemoteResponse: true,\n\n  latency: 50,\n\n  /**\n    Implement this method in order to provide data associated with a type\n\n    @method fixturesForType\n    @param  type\n  */\n  fixturesForType: function(type) {\n    if (type.FIXTURES) {\n      var fixtures = Ember.A(type.FIXTURES);\n      return fixtures.map(function(fixture){\n        var fixtureIdType = typeof fixture.id;\n        if(fixtureIdType !== \"number\" && fixtureIdType !== \"string\"){\n          throw new Error(fmt('the id property must be defined as a number or string for fixture %@', [fixture]));\n        }\n        fixture.id = fixture.id + '';\n        return fixture;\n      });\n    }\n    return null;\n  },\n\n  /**\n    Implement this method in order to query fixtures data\n\n    @method queryFixtures\n    @param  fixture\n    @param  query\n    @param  type\n  */\n  queryFixtures: function(fixtures, query, type) {\n    Ember.assert('Not implemented: You must override the DS.FixtureAdapter::queryFixtures method to support querying the fixture store.');\n  },\n\n  /**\n    @method updateFixtures\n    @param  type\n    @param  fixture\n  */\n  updateFixtures: function(type, fixture) {\n    if(!type.FIXTURES) {\n      type.FIXTURES = [];\n    }\n\n    var fixtures = type.FIXTURES;\n\n    this.deleteLoadedFixture(type, fixture);\n\n    fixtures.push(fixture);\n  },\n\n  /**\n    Implement this method in order to provide json for CRUD methods\n\n    @method mockJSON\n    @param  type\n    @param  record\n  */\n  mockJSON: function(store, type, record) {\n    return store.serializerFor(type).serialize(record, { includeId: true });\n  },\n\n  /**\n    @method generateIdForRecord\n    @param  store\n    @param  record\n  */\n  generateIdForRecord: function(store) {\n    return \"fixture-\" + counter++;\n  },\n\n  /**\n    @method find\n    @param  store\n    @param  type\n    @param  id\n  */\n  find: function(store, type, id) {\n    var fixtures = this.fixturesForType(type),\n        fixture;\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    if (fixtures) {\n      fixture = Ember.A(fixtures).findProperty('id', id);\n    }\n\n    if (fixture) {\n      return this.simulateRemoteCall(function() {\n        return fixture;\n      }, this);\n    }\n  },\n\n  /**\n    @method findMany\n    @param  store\n    @param  type\n    @param  ids\n  */\n  findMany: function(store, type, ids) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    if (fixtures) {\n      fixtures = fixtures.filter(function(item) {\n        return indexOf(ids, item.id) !== -1;\n      });\n    }\n\n    if (fixtures) {\n      return this.simulateRemoteCall(function() {\n        return fixtures;\n      }, this);\n    }\n  },\n\n  /**\n    @method findAll\n    @param  store\n    @param  type\n  */\n  findAll: function(store, type) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    return this.simulateRemoteCall(function() {\n      return fixtures;\n    }, this);\n  },\n\n  /**\n    @method findQuery\n    @param  store\n    @param  type\n    @param  query\n    @param  array\n  */\n  findQuery: function(store, type, query, array) {\n    var fixtures = this.fixturesForType(type);\n\n    Ember.assert(\"Unable to find fixtures for model type \"+type.toString(), fixtures);\n\n    fixtures = this.queryFixtures(fixtures, query, type);\n\n    if (fixtures) {\n      return this.simulateRemoteCall(function() {\n        return fixtures;\n      }, this);\n    }\n  },\n\n  /**\n    @method createRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  createRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.updateFixtures(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      return fixture;\n    }, this);\n  },\n\n  /**\n    @method updateRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  updateRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.updateFixtures(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      return fixture;\n    }, this);\n  },\n\n  /**\n    @method deleteRecord\n    @param  store\n    @param  type\n    @param  record\n  */\n  deleteRecord: function(store, type, record) {\n    var fixture = this.mockJSON(store, type, record);\n\n    this.deleteLoadedFixture(type, fixture);\n\n    return this.simulateRemoteCall(function() {\n      // no payload in a deletion\n      return null;\n    });\n  },\n\n  /*\n    @method deleteLoadedFixture\n    @private\n    @param type\n    @param record\n  */\n  deleteLoadedFixture: function(type, record) {\n    var existingFixture = this.findExistingFixture(type, record);\n\n    if(existingFixture) {\n      var index = indexOf(type.FIXTURES, existingFixture);\n      type.FIXTURES.splice(index, 1);\n      return true;\n    }\n  },\n\n  /*\n    @method findExistingFixture\n    @private\n    @param type\n    @param record\n  */\n  findExistingFixture: function(type, record) {\n    var fixtures = this.fixturesForType(type);\n    var id = get(record, 'id');\n\n    return this.findFixtureById(fixtures, id);\n  },\n\n  /*\n    @method findFixtureById\n    @private\n    @param type\n    @param record\n  */\n  findFixtureById: function(fixtures, id) {\n    return Ember.A(fixtures).find(function(r) {\n      if(''+get(r, 'id') === ''+id) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  },\n\n  /*\n    @method simulateRemoteCall\n    @private\n    @param callback\n    @param context\n  */\n  simulateRemoteCall: function(callback, context) {\n    var adapter = this;\n\n    return new Ember.RSVP.Promise(function(resolve) {\n      if (get(adapter, 'simulateRemoteResponse')) {\n        // Schedule with setTimeout\n        Ember.run.later(function() {\n          resolve(callback.call(context));\n        }, get(adapter, 'latency'));\n      } else {\n        // Asynchronous, but at the of the runloop with zero latency\n        Ember.run.once(function() {\n          resolve(callback.call(context));\n        });\n      }\n    });\n  }\n});\n\n})();\n//@ sourceURL=ember-data/adapters/fixture_adapter");