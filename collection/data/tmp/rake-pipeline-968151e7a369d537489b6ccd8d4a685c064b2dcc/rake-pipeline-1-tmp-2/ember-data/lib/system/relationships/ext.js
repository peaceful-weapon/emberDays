minispade.register('ember-data/system/relationships/ext', "(function() {minispade.require(\"ember-inflector/system\");\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  @module ember-data\n*/\n\n/*\n  This file defines several extensions to the base `DS.Model` class that\n  add support for one-to-many relationships.\n*/\n\n/**\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopen({\n\n  /**\n    This Ember.js hook allows an object to be notified when a property\n    is defined.\n\n    In this case, we use it to be notified when an Ember Data user defines a\n    belongs-to relationship. In that case, we need to set up observers for\n    each one, allowing us to track relationship changes and automatically\n    reflect changes in the inverse has-many array.\n\n    This hook passes the class being set up, as well as the key and value\n    being defined. So, for example, when the user does this:\n\n      DS.Model.extend({\n        parent: DS.belongsTo('user')\n      });\n\n    This hook would be called with \"parent\" as the key and the computed\n    property returned by `DS.belongsTo` as the value.\n\n    @method didDefineProperty\n    @param proto\n    @param key\n    @param value\n  */\n  didDefineProperty: function(proto, key, value) {\n    // Check if the value being set is a computed property.\n    if (value instanceof Ember.Descriptor) {\n\n      // If it is, get the metadata for the relationship. This is\n      // populated by the `DS.belongsTo` helper when it is creating\n      // the computed property.\n      var meta = value.meta();\n\n      if (meta.isRelationship && meta.kind === 'belongsTo') {\n        Ember.addObserver(proto, key, null, 'belongsToDidChange');\n        Ember.addBeforeObserver(proto, key, null, 'belongsToWillChange');\n      }\n\n      meta.parentType = proto.constructor;\n    }\n  }\n});\n\n/*\n  These DS.Model extensions add class methods that provide relationship\n  introspection abilities about relationships.\n\n  A note about the computed properties contained here:\n\n  **These properties are effectively sealed once called for the first time.**\n  To avoid repeatedly doing expensive iteration over a model's fields, these\n  values are computed once and then cached for the remainder of the runtime of\n  your application.\n\n  If your application needs to modify a class after its initial definition\n  (for example, using `reopen()` to add additional attributes), make sure you\n  do it before using your model with the store, which uses these properties\n  extensively.\n*/\n\nDS.Model.reopenClass({\n  /**\n    For a given relationship name, returns the model type of the relationship.\n\n    For example, if you define a model like this:\n\n        App.Post = DS.Model.extend({\n          comments: DS.hasMany('comment')\n        });\n\n    Calling `App.Post.typeForRelationship('comments')` will return `App.Comment`.\n\n    @method typeForRelationship\n    @static\n    @param {String} name the name of the relationship\n    @return {subclass of DS.Model} the type of the relationship, or undefined\n  */\n  typeForRelationship: function(name) {\n    var relationship = get(this, 'relationshipsByName').get(name);\n    return relationship && relationship.type;\n  },\n\n  inverseFor: function(name) {\n    var inverseType = this.typeForRelationship(name);\n\n    if (!inverseType) { return null; }\n\n    var options = this.metaForProperty(name).options;\n\n    if (options.inverse === null) { return null; }\n    \n    var inverseName, inverseKind;\n\n    if (options.inverse) {\n      inverseName = options.inverse;\n      inverseKind = Ember.get(inverseType, 'relationshipsByName').get(inverseName).kind;\n    } else {\n      var possibleRelationships = findPossibleInverses(this, inverseType);\n\n      if (possibleRelationships.length === 0) { return null; }\n\n      Ember.assert(\"You defined the '\" + name + \"' relationship on \" + this + \", but multiple possible inverse relationships of type \" + this + \" were found on \" + inverseType + \".\", possibleRelationships.length === 1);\n\n      inverseName = possibleRelationships[0].name;\n      inverseKind = possibleRelationships[0].kind;\n    }\n\n    function findPossibleInverses(type, inverseType, possibleRelationships) {\n      possibleRelationships = possibleRelationships || [];\n\n      var relationshipMap = get(inverseType, 'relationships');\n      if (!relationshipMap) { return; }\n\n      var relationships = relationshipMap.get(type);\n      if (relationships) {\n        possibleRelationships.push.apply(possibleRelationships, relationshipMap.get(type));\n      }\n\n      if (type.superclass) {\n        findPossibleInverses(type.superclass, inverseType, possibleRelationships);\n      }\n\n      return possibleRelationships;\n    }\n\n    return {\n      type: inverseType,\n      name: inverseName,\n      kind: inverseKind\n    };\n  },\n\n  /**\n    The model's relationships as a map, keyed on the type of the\n    relationship. The value of each entry is an array containing a descriptor\n    for each relationship with that type, describing the name of the relationship\n    as well as the type.\n\n    For example, given the following model definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany('user'),\n          owner: DS.belongsTo('user'),\n          posts: DS.hasMany('post')\n        });\n\n    This computed property would return a map describing these\n    relationships, like this:\n\n        var relationships = Ember.get(App.Blog, 'relationships');\n        relationships.get(App.User);\n        //=> [ { name: 'users', kind: 'hasMany' },\n        //     { name: 'owner', kind: 'belongsTo' } ]\n        relationships.get(App.Post);\n        //=> [ { name: 'posts', kind: 'hasMany' } ]\n\n    @property relationships\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  relationships: Ember.computed(function() {\n    var map = new Ember.MapWithDefault({\n      defaultValue: function() { return []; }\n    });\n\n    // Loop through each computed property on the class\n    this.eachComputedProperty(function(name, meta) {\n\n      // If the computed property is a relationship, add\n      // it to the map.\n      if (meta.isRelationship) {\n        if (typeof meta.type === 'string') {\n          meta.type = this.store.modelFor(meta.type);\n        }\n\n        var relationshipsForType = map.get(meta.type);\n\n        relationshipsForType.push({ name: name, kind: meta.kind });\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A hash containing lists of the model's relationships, grouped\n    by the relationship kind. For example, given a model with this\n    definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany('user'),\n          owner: DS.belongsTo('user'),\n\n          posts: DS.hasMany('post')\n        });\n\n    This property would contain the following:\n\n       var relationshipNames = Ember.get(App.Blog, 'relationshipNames');\n       relationshipNames.hasMany;\n       //=> ['users', 'posts']\n       relationshipNames.belongsTo;\n       //=> ['owner']\n\n    @property relationshipNames\n    @static\n    @type Object\n    @readOnly\n  */\n  relationshipNames: Ember.computed(function() {\n    var names = { hasMany: [], belongsTo: [] };\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        names[meta.kind].push(name);\n      }\n    });\n\n    return names;\n  }),\n\n  /**\n    An array of types directly related to a model. Each type will be\n    included once, regardless of the number of relationships it has with\n    the model.\n\n    For example, given a model with this definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany('user'),\n          owner: DS.belongsTo('user'),\n  \n          posts: DS.hasMany('post')\n        });\n\n    This property would contain the following:\n\n       var relatedTypes = Ember.get(App.Blog, 'relatedTypes');\n       //=> [ App.User, App.Post ]\n\n    @property relatedTypes\n    @static\n    @type Ember.Array\n    @readOnly\n  */\n  relatedTypes: Ember.computed(function() {\n    var type,\n        types = Ember.A();\n\n    // Loop through each computed property on the class,\n    // and create an array of the unique types involved\n    // in relationships\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        type = meta.type;\n\n        if (typeof type === 'string') {\n          type = get(this, type, false) || this.store.modelFor(type);\n        }\n\n        Ember.assert(\"You specified a hasMany (\" + meta.type + \") on \" + meta.parentType + \" but \" + meta.type + \" was not found.\",  type);\n\n        if (!types.contains(type)) {\n          Ember.assert(\"Trying to sideload \" + name + \" on \" + this.toString() + \" but the type doesn't exist.\", !!type);\n          types.push(type);\n        }\n      }\n    });\n\n    return types;\n  }),\n\n  /**\n    A map whose keys are the relationships of a model and whose values are\n    relationship descriptors.\n\n    For example, given a model with this\n    definition:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany('user'),\n          owner: DS.belongsTo('user'),\n\n          posts: DS.hasMany('post')\n        });\n\n    This property would contain the following:\n\n       var relationshipsByName = Ember.get(App.Blog, 'relationshipsByName');\n       relationshipsByName.get('users');\n       //=> { key: 'users', kind: 'hasMany', type: App.User }\n       relationshipsByName.get('owner');\n       //=> { key: 'owner', kind: 'belongsTo', type: App.User }\n\n    @property relationshipsByName\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  relationshipsByName: Ember.computed(function() {\n    var map = Ember.Map.create(), type;\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        meta.key = name;\n        type = meta.type;\n\n        if (!type && meta.kind === 'hasMany') {\n          type = Ember.String.singularize(name);\n        } else if (!type) {\n          type = name;\n        }\n\n        if (typeof type === 'string') {\n          meta.type = this.store.modelFor(type);\n        }\n\n        map.set(name, meta);\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    A map whose keys are the fields of the model and whose values are strings\n    describing the kind of the field. A model's fields are the union of all of its\n    attributes and relationships.\n\n    For example:\n\n        App.Blog = DS.Model.extend({\n          users: DS.hasMany('user'),\n          owner: DS.belongsTo('user'),\n\n          posts: DS.hasMany('post'),\n\n          title: DS.attr('string')\n        });\n\n        var fields = Ember.get(App.Blog, 'fields');\n        fields.forEach(function(field, kind) {\n          console.log(field, kind);\n        });\n\n        // prints:\n        // users, hasMany\n        // owner, belongsTo\n        // posts, hasMany\n        // title, attribute\n\n    @property fields\n    @static\n    @type Ember.Map\n    @readOnly\n  */\n  fields: Ember.computed(function() {\n    var map = Ember.Map.create();\n\n    this.eachComputedProperty(function(name, meta) {\n      if (meta.isRelationship) {\n        map.set(name, meta.kind);\n      } else if (meta.isAttribute) {\n        map.set(name, 'attribute');\n      }\n    });\n\n    return map;\n  }),\n\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @method eachRelationship\n    @static\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    get(this, 'relationshipsByName').forEach(function(name, relationship) {\n      callback.call(binding, name, relationship);\n    });\n  },\n\n  /**\n    Given a callback, iterates over each of the types related to a model,\n    invoking the callback with the related type's class. Each type will be\n    returned just once, regardless of how many different relationships it has\n    with a model.\n\n    @method eachRelatedType\n    @static\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelatedType: function(callback, binding) {\n    get(this, 'relatedTypes').forEach(function(type) {\n      callback.call(binding, type);\n    });\n  }\n});\n\nDS.Model.reopen({\n  /**\n    Given a callback, iterates over each of the relationships in the model,\n    invoking the callback with the name of each relationship and its relationship\n    descriptor.\n\n    @method eachRelationship\n    @param {Function} callback the callback to invoke\n    @param {any} binding the value to which the callback's `this` should be bound\n  */\n  eachRelationship: function(callback, binding) {\n    this.constructor.eachRelationship(callback, binding);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/ext");