minispade.register('ember-data/system/store', "(function() {/*globals Ember*/\n/*jshint eqnull:true*/\nminispade.require(\"ember-data/system/record_arrays\");\nminispade.require(\"ember-data/system/mixins/mappable\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar isNone = Ember.isNone;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar indexOf = Ember.EnumerableUtils.indexOf;\nvar map = Ember.EnumerableUtils.map;\nvar resolve = Ember.RSVP.resolve;\n\n// Implementors Note:\n//\n//   The variables in this file are consistently named according to the following\n//   scheme:\n//\n//   * +id+ means an identifier managed by an external source, provided inside\n//     the data provided by that source. These are always coerced to be strings\n//     before being used internally.\n//   * +clientId+ means a transient numerical identifier generated at runtime by\n//     the data store. It is important primarily because newly created objects may\n//     not yet have an externally generated id.\n//   * +reference+ means a record reference object, which holds metadata about a\n//     record, even if it has not yet been fully materialized.\n//   * +type+ means a subclass of DS.Model.\n\n// Used by the store to normalize IDs entering the store.  Despite the fact\n// that developers may provide IDs as numbers (e.g., `store.find(Person, 1)`),\n// it is important that internally we use strings, since IDs may be serialized\n// and lose type information.  For example, Ember's router may put a record's\n// ID into the URL, and if we later try to deserialize that URL and find the\n// corresponding record, we will not know if it is a string or a number.\nvar coerceId = function(id) {\n  return id == null ? null : id+'';\n};\n\n/**\n  The store contains all of the data for records loaded from the server.\n  It is also responsible for creating instances of DS.Model that wrap\n  the individual data for a record, so that they can be bound to in your\n  Handlebars templates.\n\n  Define your application's store like this:\n\n       MyApp.Store = DS.Store.extend();\n\n  Most Ember.js applications will only have a single `DS.Store` that is\n  automatically created by their `Ember.Application`.\n\n  You can retrieve models from the store in several ways. To retrieve a record\n  for a specific id, use `DS.Model`'s `find()` method:\n\n       var person = App.Person.find(123);\n\n  If your application has multiple `DS.Store` instances (an unusual case), you can\n  specify which store should be used:\n\n      var person = store.find(App.Person, 123);\n\n  In general, you should retrieve models using the methods on `DS.Model`; you should\n  rarely need to interact with the store directly.\n\n  By default, the store will talk to your backend using a standard REST mechanism.\n  You can customize how the store talks to your backend by specifying a custom adapter:\n\n       MyApp.store = DS.Store.create({\n         adapter: 'MyApp.CustomAdapter'\n       });\n\n  You can learn more about writing a custom adapter by reading the `DS.Adapter`\n  documentation.\n\n  @class Store\n  @namespace DS\n  @extends Ember.Object\n  @uses DS._Mappable\n*/\nDS.Store = Ember.Object.extend(DS._Mappable, {\n\n  /**\n    @method init\n    @private\n  */\n  init: function() {\n    // internal bookkeeping; not observable\n    this.typeMaps = {};\n    this.recordArrayManager = DS.RecordArrayManager.create({\n      store: this\n    });\n    this._relationshipChanges = {};\n    this._pendingSave = [];\n  },\n\n  /**\n    The adapter to use to communicate to a backend server or other persistence layer.\n\n    This can be specified as an instance, class, or string.\n\n    If you want to specify `App.CustomAdapter` as a string, do:\n\n    ```js\n    adapter: 'custom'\n    ```\n\n    @property adapter\n    @default DS.RESTAdapter\n    @type {DS.Adapter|String}\n  */\n  adapter: '_rest',\n\n  /**\n    Returns a JSON representation of the record using a custom\n    type-specific serializer, if one exists.\n\n    The available options are:\n\n    * `includeId`: `true` if the record's ID should be included in\n      the JSON representation\n\n    @method serialize\n    @private\n    @param {DS.Model} record the record to serialize\n    @param {Object} options an options hash\n  */\n  serialize: function(record, options) {\n    return this.serializerFor(record.constructor.typeKey).serialize(record, options);\n  },\n\n  /**\n    This property returns the adapter, after resolving a possible\n    string key.\n\n    If the supplied `adapter` was a class, or a String property\n    path resolved to a class, this property will instantiate the\n    class.\n\n    This property is cacheable, so the same instance of a specified\n    adapter class should be used for the lifetime of the store.\n\n    @property defaultAdapter\n    @private\n    @returns DS.Adapter\n  */\n  defaultAdapter: Ember.computed(function() {\n    var adapter = get(this, 'adapter');\n\n    Ember.assert('You tried to set `adapter` property to an instance of `DS.Adapter`, where it should be a name or a factory', !(adapter instanceof DS.Adapter));\n\n    if (typeof adapter === 'string') {\n      adapter = this.container.lookup('adapter:' + adapter) || this.container.lookup('adapter:application') || this.container.lookup('adapter:_rest');\n    }\n\n    if (DS.Adapter.detect(adapter)) {\n      adapter = adapter.create({ container: this.container });\n    }\n\n    return adapter;\n  }).property('adapter'),\n\n  // .....................\n  // . CREATE NEW RECORD .\n  // .....................\n\n  /**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n\n    To create a new instance of `App.Post`:\n\n    ```js\n    store.createRecord('post', {\n      title: \"Rails is omakase\"\n    });\n    ```\n\n    @method createRecord\n    @param {String} type\n    @param {Object} properties a hash of properties to set on the\n      newly created record.\n    @returns DS.Model\n  */\n  createRecord: function(type, properties) {\n    type = this.modelFor(type);\n\n    properties = properties || {};\n\n    // If the passed properties do not include a primary key,\n    // give the adapter an opportunity to generate one. Typically,\n    // client-side ID generators will use something like uuid.js\n    // to avoid conflicts.\n\n    if (isNone(properties.id)) {\n      properties.id = this._generateId(type);\n    }\n\n    // Coerce ID to a string\n    properties.id = coerceId(properties.id);\n\n    var record = this.buildRecord(type, properties.id);\n\n    // Move the record out of its initial `empty` state into\n    // the `loaded` state.\n    record.loadedData();\n\n    // Set the properties specified on the record.\n    record.setProperties(properties);\n\n    return record;\n  },\n\n  /**\n    If possible, this method asks the adapter to generate an ID for\n    a newly created record.\n\n    @method generateId\n    @param {String} type\n    @returns String if the adapter can generate one, an ID\n  */\n  _generateId: function(type) {\n    var adapter = this.adapterFor(type);\n\n    if (adapter && adapter.generateIdForRecord) {\n      return adapter.generateIdForRecord(this);\n    }\n\n    return null;\n  },\n\n  // .................\n  // . DELETE RECORD .\n  // .................\n\n  /**\n    For symmetry, a record can be deleted via the store.\n\n    @method deleteRecord\n    @param {DS.Model} record\n  */\n  deleteRecord: function(record) {\n    record.deleteRecord();\n  },\n\n  /**\n    For symmetry, a record can be unloaded via the store.\n\n    @method unloadRecord\n    @param {DS.Model} record\n  */\n  unloadRecord: function(record) {\n    record.unloadRecord();\n  },\n\n  // ................\n  // . FIND RECORDS .\n  // ................\n\n  /**\n    This is the main entry point into finding records. The first parameter to\n    this method is the model's name as a string.\n\n    ---\n\n    To find a record by ID, pass the `id` as the second parameter:\n\n        store.find('person', 1);\n\n    The `find` method will always return a **promise** that will be resolved\n    with the record. If the record was already in the store, the promise will\n    be resolved immediately. Otherwise, the store will ask the adapter's `find`\n    method to find the necessary data.\n\n    The `find` method will always resolve its promise with the same object for\n    a given type and `id`.\n\n    ---\n\n    To find all records for a type, call `find` with no additional parameters:\n\n        store.find('person');\n\n    This will ask the adapter's `findAll` method to find the records for the\n    given type, and return a promise that will be resolved once the server\n    returns the values.\n\n    ---\n\n    To find a record by a query, call `find` with a hash as the second\n    parameter:\n\n        store.find(App.Person, { page: 1 });\n\n    This will ask the adapter's `findQuery` method to find the records for\n    the query, and return a promise that will be resolved once the server\n    responds.\n\n    @method find\n    @param {DS.Model} type\n    @param {Object|String|Integer|null} id\n  */\n  find: function(type, id) {\n    if (id === undefined) {\n      return this.findAll(type);\n    }\n\n    // We are passed a query instead of an id.\n    if (Ember.typeOf(id) === 'object') {\n      return this.findQuery(type, id);\n    }\n\n    return this.findById(type, coerceId(id));\n  },\n\n  /**\n    This method returns a record for a given type and id combination.\n\n    @method findById\n    @private\n    @param type\n    @param id\n  */\n  findById: function(type, id) {\n    type = this.modelFor(type);\n\n    var record = this.recordForId(type, id);\n\n    var promise = this.fetchRecord(record) || resolve(record);\n    return promiseObject(promise);\n  },\n\n  /**\n    This method makes a series of requests to the adapter's `find` method\n    and returns a promise that resolves once they are all loaded.\n\n    @method findByIds\n    @param {String} type\n    @param {Array} ids\n    @returns Promise\n  */\n  findByIds: function(type, ids) {\n    var store = this;\n\n    return promiseArray(Ember.RSVP.all(map(ids, function(id) {\n      return store.findById(type, id);\n    })).then(function(array) {\n      return Ember.A(array);\n    }));\n  },\n\n  /**\n    This method is called by `findById` if it discovers that a particular\n    type/id pair hasn't been loaded yet to kick off a request to the\n    adapter.\n\n    @method fetchRecord\n    @private\n    @param {DS.Model} record\n    @returns Promise\n  */\n  fetchRecord: function(record) {\n    if (isNone(record)) { return null; }\n    if (record._loadingPromise) { return record._loadingPromise; }\n    if (!get(record, 'isEmpty')) { return null; }\n\n    var type = record.constructor,\n        id = get(record, 'id'),\n        resolver = Ember.RSVP.defer();\n\n    record.loadingData(resolver.promise);\n\n    var adapter = this.adapterFor(type);\n\n    Ember.assert(\"You tried to find a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to find a record but your adapter (for \" + type + \") does not implement 'find'\", adapter.find);\n\n    _find(adapter, this, type, id, resolver);\n\n    return resolver.promise;\n  },\n\n  /**\n    Get a record by a given type and ID without triggering a fetch.\n\n    This method will synchronously return the record if it's available.\n    Otherwise, it will return null.\n\n    ```js\n    var post = store.getById('post', 1);\n    ```\n\n    @method getById\n    @param type\n    @param id\n  */\n  getById: function(type, id) {\n    type = this.modelFor(type);\n\n    if (this.hasRecordForId(type, id)) {\n      return this.recordForId(type, id);\n    } else {\n      return null;\n    }\n  },\n\n  /**\n    This method is called by the record's `reload` method. The record's `reload`\n    passes in a resolver for the promise it returns.\n\n    This method calls the adapter's `find` method, which returns a promise. When\n    **that** promise resolves, `reloadRecord` will resolve the promise returned\n    by the record's `reload`.\n\n    @method reloadRecord\n    @private\n    @param {DS.Model} record\n    @param {Resolver} resolver\n  */\n  reloadRecord: function(record, resolver) {\n    var type = record.constructor,\n        adapter = this.adapterFor(type),\n        id = get(record, 'id');\n\n    Ember.assert(\"You cannot reload a record without an ID\", id);\n    Ember.assert(\"You tried to reload a record but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to reload a record but your adapter does not implement `find`\", adapter.find);\n\n    return _find(adapter, this, type, id, resolver);\n  },\n\n  /**\n    This method takes a list of records, groups the records by type,\n    converts the records into IDs, and then invokes the adapter's `findMany`\n    method.\n\n    The records are grouped by type to invoke `findMany` on adapters\n    for each unique type in records.\n\n    It is used both by a brand new relationship (via the `findMany`\n    method) or when the data underlying an existing relationship\n    changes.\n\n    @method fetchMany\n    @private\n    @param records\n    @param owner\n  */\n  fetchMany: function(records, owner, resolver) {\n    if (!records.length) { return; }\n\n    // Group By Type\n    var recordsByTypeMap = Ember.MapWithDefault.create({\n      defaultValue: function() { return Ember.A(); }\n    });\n\n    forEach(records, function(record) {\n      recordsByTypeMap.get(record.constructor).push(record);\n    });\n\n    forEach(recordsByTypeMap, function(type, records) {\n      var ids = records.mapProperty('id'),\n          adapter = this.adapterFor(type);\n\n      Ember.assert(\"You tried to load many records but you have no adapter (for \" + type + \")\", adapter);\n      Ember.assert(\"You tried to load many records but your adapter does not implement `findMany`\", adapter.findMany);\n\n      _findMany(adapter, this, type, ids, owner, resolver);\n    }, this);\n  },\n\n  /**\n    Returns true if a record for a given type and ID is already loaded.\n\n    @method hasRecordForId\n    @param {DS.Model} type\n    @param {String|Integer} id\n    @returns Boolean\n  */\n  hasRecordForId: function(type, id) {\n    id = coerceId(id);\n\n    return !!this.typeMapFor(type).idToRecord[id];\n  },\n\n  /**\n    Returns id record for a given type and ID. If one isn't already loaded,\n    it builds a new record and leaves it in the `empty` state.\n\n    @method recordForId\n    @param {String} type\n    @param {String|Integer} id\n    @returns DS.Model\n  */\n  recordForId: function(type, id) {\n    type = this.modelFor(type);\n\n    id = coerceId(id);\n\n    var record = this.typeMapFor(type).idToRecord[id];\n\n    if (!record) {\n      record = this.buildRecord(type, id);\n    }\n\n    return record;\n  },\n\n  /**\n    @method findMany\n    @private\n    @param {DS.Model} owner\n    @param {Array<DS.Model>} records\n    @param {String} type\n    @param {Resolver} resolver\n    @return DS.ManyArray\n  */\n  findMany: function(owner, records, type, resolver) {\n    type = this.modelFor(type);\n\n    records = Ember.A(records);\n\n    var unloadedRecords = records.filterProperty('isEmpty', true),\n        manyArray = this.recordArrayManager.createManyArray(type, records);\n\n    forEach(unloadedRecords, function(record) {\n      record.loadingData();\n    });\n\n    manyArray.loadingRecordsCount = unloadedRecords.length;\n\n    if (unloadedRecords.length) {\n      forEach(unloadedRecords, function(record) {\n        this.recordArrayManager.registerWaitingRecordArray(record, manyArray);\n      }, this);\n\n      this.fetchMany(unloadedRecords, owner, resolver);\n    } else {\n      if (resolver) { resolver.resolve(); }\n      manyArray.set('isLoaded', true);\n      Ember.run.once(manyArray, 'trigger', 'didLoad');\n    }\n\n    return manyArray;\n  },\n\n  /**\n    If a relationship was originally populated by the adapter as a link\n    (as opposed to a list of IDs), this method is called when the\n    relationship is fetched.\n\n    The link (which is usually a URL) is passed through unchanged, so the\n    adapter can make whatever request it wants.\n\n    The usual use-case is for the server to register a URL as a link, and\n    then use that URL in the future to make a request for the relationship.\n\n    @method findHasMany\n    @private\n    @param {DS.Model} owner\n    @param {any} link\n    @param {String} type\n    @param {Resolver} resolver\n    @return DS.ManyArray\n  */\n  findHasMany: function(owner, link, relationship, resolver) {\n    var adapter = this.adapterFor(owner.constructor);\n\n    Ember.assert(\"You tried to load a hasMany relationship but you have no adapter (for \" + owner.constructor + \")\", adapter);\n    Ember.assert(\"You tried to load a hasMany relationship from a specified `link` in the original payload but your adapter does not implement `findHasMany`\", adapter.findHasMany);\n\n    var records = this.recordArrayManager.createManyArray(relationship.type, Ember.A([]));\n    _findHasMany(adapter, this, owner, link, relationship, resolver);\n    return records;\n  },\n\n  findBelongsTo: function(owner, link, relationship, resolver) {\n    var adapter = this.adapterFor(owner.constructor);\n\n    Ember.assert(\"You tried to load a belongsTo relationship but you have no adapter (for \" + owner.constructor + \")\", adapter);\n    Ember.assert(\"You tried to load a belongsTo relationship from a specified `link` in the original payload but your adapter does not implement `findBelongsTo`\", adapter.findBelongsTo);\n\n    _findBelongsTo(adapter, this, owner, link, relationship, resolver);\n  },\n\n  /**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n\n    Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n\n    This method returns a promise, which is resolved with a `RecordArray`\n    once the server returns.\n\n    @method findQuery\n    @private\n    @param {String} type\n    @param {any} query an opaque query to be used by the adapter\n    @return Promise\n  */\n  findQuery: function(type, query) {\n    type = this.modelFor(type);\n\n    var array = DS.AdapterPopulatedRecordArray.create({\n      type: type,\n      query: query,\n      content: Ember.A(),\n      store: this\n    });\n\n    var adapter = this.adapterFor(type),\n        resolver = Ember.RSVP.defer();\n\n    Ember.assert(\"You tried to load a query but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load a query but your adapter does not implement `findQuery`\", adapter.findQuery);\n\n    _findQuery(adapter, this, type, query, array, resolver);\n\n    return promiseArray(resolver.promise);\n  },\n\n  /**\n    This method returns an array of all records adapter can find.\n    It triggers the adapter's `findAll` method to give it an opportunity to populate\n    the array with records of that type.\n\n    @method findAll\n    @private\n    @param {Class} type\n    @return {DS.AdapterPopulatedRecordArray}\n  */\n  findAll: function(type) {\n    type = this.modelFor(type);\n\n    return this.fetchAll(type, this.all(type));\n  },\n\n  /**\n    @method fetchAll\n    @private\n    @param type\n    @param array\n    @returns Promise\n  */\n  fetchAll: function(type, array) {\n    var adapter = this.adapterFor(type),\n        sinceToken = this.typeMapFor(type).metadata.since,\n        resolver = Ember.RSVP.defer();\n\n    set(array, 'isUpdating', true);\n\n    Ember.assert(\"You tried to load all records but you have no adapter (for \" + type + \")\", adapter);\n    Ember.assert(\"You tried to load all records but your adapter does not implement `findAll`\", adapter.findAll);\n\n    _findAll(adapter, this, type, sinceToken, resolver);\n\n    return promiseArray(resolver.promise);\n  },\n\n  /**\n    @method didUpdateAll\n    @param type\n  */\n  didUpdateAll: function(type) {\n    var findAllCache = this.typeMapFor(type).findAllCache;\n    set(findAllCache, 'isUpdating', false);\n  },\n\n  /**\n    This method returns a filtered array that contains all of the known records\n    for a given type.\n\n    Note that because it's just a filter, it will have any locally\n    created records of the type.\n\n    Also note that multiple calls to `all` for a given type will always\n    return the same RecordArray.\n\n    @method all\n    @param {Class} type\n    @return {DS.RecordArray}\n  */\n  all: function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        findAllCache = typeMap.findAllCache;\n\n    if (findAllCache) { return findAllCache; }\n\n    var array = DS.RecordArray.create({\n      type: type,\n      content: Ember.A(),\n      store: this,\n      isLoaded: true\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type);\n\n    typeMap.findAllCache = array;\n    return array;\n  },\n\n\n  /**\n    This method unloads all of the known records for a given type.\n\n    @method unloadAll\n    @param {Class} type\n  */\n  unloadAll: function(type) {\n    type = this.modelFor(type);\n\n    var typeMap = this.typeMapFor(type),\n        records = typeMap.records, record;\n\n    while(record = records.pop()) {\n      record.unloadRecord();\n    }\n  },\n\n  /**\n    Takes a type and filter function, and returns a live RecordArray that\n    remains up to date as new records are loaded into the store or created\n    locally.\n\n    The callback function takes a materialized record, and returns true\n    if the record should be included in the filter and false if it should\n    not.\n\n    The filter function is called once on all records for the type when\n    it is created, and then once on each newly loaded or created record.\n\n    If any of a record's properties change, or if it changes state, the\n    filter function will be invoked again to determine whether it should\n    still be in the array.\n    \n    Optionally you can pass a query which will be triggered at first. The\n    results returned by the server could then appear in the filter if they\n    match the filter function.\n\n    @method filter\n    @param {Class} type\n    @param {Object} query optional query\n    @param {Function} filter\n    @return {DS.FilteredRecordArray}\n  */\n  filter: function(type, query, filter) {\n    var promise;\n\n    // allow an optional server query\n    if (arguments.length === 3) {\n      promise = this.findQuery(type, query);\n    } else if (arguments.length === 2) {\n      filter = query;\n    }\n\n    type = this.modelFor(type);\n\n    var array = DS.FilteredRecordArray.create({\n      type: type,\n      content: Ember.A(),\n      store: this,\n      manager: this.recordArrayManager,\n      filterFunction: filter\n    });\n\n    this.recordArrayManager.registerFilteredRecordArray(array, type, filter);\n\n    if (promise) {\n      return promise.then(function() { return array; });\n    } else {\n      return array;\n    }\n  },\n\n  /**\n    This method returns if a certain record is already loaded\n    in the store. Use this function to know beforehand if a find()\n    will result in a request or that it will be a cache hit.\n\n    @method recordIsLoaded\n    @param {Class} type\n    @param {string} id\n    @return {boolean}\n  */\n  recordIsLoaded: function(type, id) {\n    if (!this.hasRecordForId(type, id)) { return false; }\n    return !get(this.recordForId(type, id), 'isEmpty');\n  },\n\n  /**\n    This method returns the metadata for a specific type.\n\n    @method metadataFor\n    @param {string} type\n    @return {object}\n  */\n  metadataFor: function(type) {\n    type = this.modelFor(type);\n    return this.typeMapFor(type).metadata;\n  },\n\n  // ............\n  // . UPDATING .\n  // ............\n\n  /**\n    If the adapter updates attributes or acknowledges creation\n    or deletion, the record will notify the store to update its\n    membership in any filters.\n\n    To avoid thrashing, this method is invoked only once per\n    run loop per record.\n\n    @method dataWasUpdated\n    @private\n    @param {Class} type\n    @param {Number|String} clientId\n    @param {DS.Model} record\n  */\n  dataWasUpdated: function(type, record) {\n    // Because data updates are invoked at the end of the run loop,\n    // it is possible that a record might be deleted after its data\n    // has been modified and this method was scheduled to be called.\n    //\n    // If that's the case, the record would have already been removed\n    // from all record arrays; calling updateRecordArrays would just\n    // add it back. If the record is deleted, just bail. It shouldn't\n    // give us any more trouble after this.\n\n    if (get(record, 'isDeleted')) { return; }\n\n    if (get(record, 'isLoaded')) {\n      this.recordArrayManager.recordDidChange(record);\n    }\n  },\n\n  // ..............\n  // . PERSISTING .\n  // ..............\n\n  /**\n    This method is called by `record.save`, and gets passed a\n    resolver for the promise that `record.save` returns.\n\n    It schedules saving to happen at the end of the run loop.\n\n    @method scheduleSave\n    @private\n    @param {DS.Model} record\n    @param {Resolver} resolver\n  */\n  scheduleSave: function(record, resolver) {\n    record.adapterWillCommit();\n    this._pendingSave.push([record, resolver]);\n    once(this, 'flushPendingSave');\n  },\n\n  /**\n    This method is called at the end of the run loop, and\n    flushes any records passed into `scheduleSave`\n\n    @method flushPendingSave\n    @private\n  */\n  flushPendingSave: function() {\n    var pending = this._pendingSave.slice();\n    this._pendingSave = [];\n\n    forEach(pending, function(tuple) {\n      var record = tuple[0], resolver = tuple[1],\n          adapter = this.adapterFor(record.constructor),\n          operation;\n\n      if (get(record, 'isNew')) {\n        operation = 'createRecord';\n      } else if (get(record, 'isDeleted')) {\n        operation = 'deleteRecord';\n      } else {\n        operation = 'updateRecord';\n      }\n\n      _commit(adapter, this, operation, record, resolver);\n    }, this);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is resolved.\n\n    If the data provides a server-generated ID, it will\n    update the record and the store's indexes.\n\n    @method didSaveRecord\n    @private\n    @param {DS.Model} record the in-flight record\n    @param {Object} data optional data (see above)\n  */\n  didSaveRecord: function(record, data) {\n    if (data) {\n      // normalize relationship IDs into records\n      data = normalizeRelationships(this, record.constructor, data, record);\n\n      this.updateId(record, data);\n    }\n\n    record.adapterDidCommit(data);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is rejected with a `DS.InvalidError`.\n\n    @method recordWasInvalid\n    @private\n    @param {DS.Model} record\n    @param {Object} errors\n  */\n  recordWasInvalid: function(record, errors) {\n    record.adapterDidInvalidate(errors);\n  },\n\n  /**\n    This method is called once the promise returned by an\n    adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    is rejected (with anything other than a `DS.InvalidError`).\n\n    @method recordWasError\n    @private\n    @param {DS.Model} record\n  */\n  recordWasError: function(record) {\n    record.adapterDidError();\n  },\n\n  /**\n    When an adapter's `createRecord`, `updateRecord` or `deleteRecord`\n    resolves with data, this method extracts the ID from the supplied\n    data.\n\n    @method updateId\n    @private\n    @param {DS.Model} record\n    @param {Object} data\n  */\n  updateId: function(record, data) {\n    var oldId = get(record, 'id'),\n        id = coerceId(data.id);\n\n    Ember.assert(\"An adapter cannot assign a new id to a record that already has an id. \" + record + \" had id: \" + oldId + \" and you tried to update it with \" + id + \". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent.\", oldId === null || id === oldId);\n\n    this.typeMapFor(record.constructor).idToRecord[id] = record;\n\n    set(record, 'id', id);\n  },\n\n  /**\n    Returns a map of IDs to client IDs for a given type.\n\n    @method typeMapFor\n    @private\n    @param type\n  */\n  typeMapFor: function(type) {\n    var typeMaps = get(this, 'typeMaps'),\n        guid = Ember.guidFor(type),\n        typeMap;\n\n    typeMap = typeMaps[guid];\n\n    if (typeMap) { return typeMap; }\n\n    typeMap = {\n      idToRecord: {},\n      records: [],\n      metadata: {}\n    };\n\n    typeMaps[guid] = typeMap;\n\n    return typeMap;\n  },\n\n  // ................\n  // . LOADING DATA .\n  // ................\n\n  /**\n    This internal method is used by `push`.\n\n    @method _load\n    @private\n    @param {DS.Model} type\n    @param {Object} data\n    @param {Boolean} partial the data should be merged into\n      the existing data, not replace it.\n  */\n  _load: function(type, data, partial) {\n    var id = coerceId(data.id),\n        record = this.recordForId(type, id);\n\n    record.setupData(data, partial);\n    this.recordArrayManager.recordDidChange(record);\n\n    return record;\n  },\n\n  /**\n    Returns a model class for a particular key. Used by\n    methods that take a type key (like `find`, `createRecord`,\n    etc.)\n\n    @method modelFor\n    @param {String or subclass of DS.Model} key\n    @returns {subclass of DS.Model}\n  */\n  modelFor: function(key) {\n    var factory;\n\n    if (typeof key === 'string') {\n      factory = this.container.lookupFactory('model:' + key);\n      Ember.assert(\"No model was found for '\" + key + \"'\", factory);\n      factory.typeKey = key;\n    } else {\n      // A factory already supplied.\n      factory = key;\n    }\n\n    factory.store = this;\n    return factory;\n  },\n\n  /**\n    Push some data for a given type into the store.\n\n    This method expects normalized data:\n\n    * The ID is a key named `id` (an ID is mandatory)\n    * The names of attributes are the ones you used in\n      your model's `DS.attr`s.\n    * Your relationships must be:\n      * represented as IDs or Arrays of IDs\n      * represented as model instances\n      * represented as URLs, under the `links` key\n\n    For this model:\n\n    ```js\n    App.Person = DS.Model.extend({\n      firstName: DS.attr(),\n      lastName: DS.attr(),\n\n      children: DS.hasMany('person')\n    });\n    ```\n\n    To represent the children as IDs:\n\n    ```js\n    {\n      id: 1,\n      firstName: \"Tom\",\n      lastName: \"Dale\",\n      children: [1, 2, 3]\n    }\n    ```\n\n    To represent the children relationship as a URL:\n\n    ```js\n    {\n      id: 1,\n      firstName: \"Tom\",\n      lastName: \"Dale\",\n      links: {\n        children: \"/people/1/children\"\n      }\n    }\n    ```\n\n    If you're streaming data or implementing an adapter,\n    make sure that you have converted the incoming data\n    into this form.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records.\n\n    @method push\n    @param {String} type\n    @param {Object} data\n    @returns DS.Model the record that was created or\n      updated.\n  */\n  push: function(type, data, _partial) {\n    // _partial is an internal param used by `update`.\n    // If passed, it means that the data should be\n    // merged into the existing data, not replace it.\n\n    Ember.assert(\"You must include an `id` in a hash passed to `push`\", data.id != null);\n\n    type = this.modelFor(type);\n\n    // normalize relationship IDs into records\n    data = normalizeRelationships(this, type, data);\n\n    this._load(type, data, _partial);\n\n    return this.recordForId(type, data.id);\n  },\n\n  /**\n    Push some raw data into the store.\n\n    The data will be automatically deserialized using the\n    serializer for the `type` param.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records.\n\n    You can push in more than one type of object at once.\n    All objects should be in the format expected by the\n    serializer.\n\n    ```js\n    App.ApplicationSerializer = DS.ActiveModelSerializer;\n\n    var pushData = {\n      posts: [\n        {id: 1, post_title: \"Great post\", comment_ids: [2]}\n      ],\n      comments: [\n        {id: 2, comment_body: \"Insightful comment\"}\n      ]\n    }\n\n    store.pushPayload('post', pushData);\n    ```\n\n    @method push\n    @param {String} type\n    @param {Object} payload\n  */\n\n  pushPayload: function (type, payload) {\n    var serializer = this.serializerFor(type);\n    serializer.pushPayload(this, payload);\n  },\n\n  update: function(type, data) {\n    Ember.assert(\"You must include an `id` in a hash passed to `update`\", data.id != null);\n\n    return this.push(type, data, true);\n  },\n\n  /**\n    If you have an Array of normalized data to push,\n    you can call `pushMany` with the Array, and it will\n    call `push` repeatedly for you.\n\n    @method pushMany\n    @param {String} type\n    @param {Array} datas\n    @return {Array<DS.Model>}\n  */\n  pushMany: function(type, datas) {\n    return map(datas, function(data) {\n      return this.push(type, data);\n    }, this);\n  },\n\n  /**\n    If you have some metadata to set for a type\n    you can call `metaForType`.\n\n    @method metaForType\n    @param {String} type\n    @param {Object} metadata\n  */\n  metaForType: function(type, metadata) {\n    type = this.modelFor(type);\n\n    Ember.merge(this.typeMapFor(type).metadata, metadata);\n  },\n\n  /**\n    Build a brand new record for a given type, ID, and\n    initial data.\n\n    @method buildRecord\n    @private\n    @param {subclass of DS.Model} type\n    @param {String} id\n    @param {Object} data\n    @returns DS.Model\n  */\n  buildRecord: function(type, id, data) {\n    var typeMap = this.typeMapFor(type),\n        idToRecord = typeMap.idToRecord;\n\n    Ember.assert('The id ' + id + ' has already been used with another record of type ' + type.toString() + '.', !id || !idToRecord[id]);\n\n    // lookupFactory should really return an object that creates\n    // instances with the injections applied\n    var record = type._create({\n      id: id,\n      store: this,\n      container: this.container\n    });\n\n    if (data) {\n      record.setupData(data);\n    }\n\n    // if we're creating an item, this process will be done\n    // later, once the object has been persisted.\n    if (id) {\n      idToRecord[id] = record;\n    }\n\n    typeMap.records.push(record);\n\n    return record;\n  },\n\n  // ...............\n  // . DESTRUCTION .\n  // ...............\n\n  /**\n    When a record is destroyed, this un-indexes it and\n    removes it from any record arrays so it can be GCed.\n\n    @method dematerializeRecord\n    @private\n    @param {DS.Model} record\n  */\n  dematerializeRecord: function(record) {\n    var type = record.constructor,\n        typeMap = this.typeMapFor(type),\n        id = get(record, 'id');\n\n    record.updateRecordArrays();\n\n    if (id) {\n      delete typeMap.idToRecord[id];\n    }\n\n    var loc = indexOf(typeMap.records, record);\n    typeMap.records.splice(loc, 1);\n  },\n\n  // ........................\n  // . RELATIONSHIP CHANGES .\n  // ........................\n\n  addRelationshipChangeFor: function(childRecord, childKey, parentRecord, parentKey, change) {\n    var clientId = childRecord.clientId,\n        parentClientId = parentRecord ? parentRecord : parentRecord;\n    var key = childKey + parentKey;\n    var changes = this._relationshipChanges;\n    if (!(clientId in changes)) {\n      changes[clientId] = {};\n    }\n    if (!(parentClientId in changes[clientId])) {\n      changes[clientId][parentClientId] = {};\n    }\n    if (!(key in changes[clientId][parentClientId])) {\n      changes[clientId][parentClientId][key] = {};\n    }\n    changes[clientId][parentClientId][key][change.changeType] = change;\n  },\n\n  removeRelationshipChangeFor: function(clientRecord, childKey, parentRecord, parentKey, type) {\n    var clientId = clientRecord.clientId,\n        parentClientId = parentRecord ? parentRecord.clientId : parentRecord;\n    var changes = this._relationshipChanges;\n    var key = childKey + parentKey;\n    if (!(clientId in changes) || !(parentClientId in changes[clientId]) || !(key in changes[clientId][parentClientId])){\n      return;\n    }\n    delete changes[clientId][parentClientId][key][type];\n  },\n\n  relationshipChangePairsFor: function(record){\n    var toReturn = [];\n\n    if( !record ) { return toReturn; }\n\n    //TODO(Igor) What about the other side\n    var changesObject = this._relationshipChanges[record.clientId];\n    for (var objKey in changesObject){\n      if(changesObject.hasOwnProperty(objKey)){\n        for (var changeKey in changesObject[objKey]){\n          if(changesObject[objKey].hasOwnProperty(changeKey)){\n            toReturn.push(changesObject[objKey][changeKey]);\n          }\n        }\n      }\n    }\n    return toReturn;\n  },\n\n  // ......................\n  // . PER-TYPE ADAPTERS\n  // ......................\n\n  /**\n    Returns the adapter for a given type.\n\n    @method adapterFor\n    @private\n    @param {subclass of DS.Model} type\n    @returns DS.Adapter\n  */\n  adapterFor: function(type) {\n    var container = this.container, adapter;\n\n    if (container) {\n      adapter = container.lookup('adapter:' + type.typeKey) || container.lookup('adapter:application');\n    }\n\n    return adapter || get(this, 'defaultAdapter');\n  },\n\n  // ..............................\n  // . RECORD CHANGE NOTIFICATION .\n  // ..............................\n\n  /**\n    Returns an instance of the serializer for a given type. For\n    example, `serializerFor('person')` will return an instance of\n    `App.PersonSerializer`.\n\n    If no `App.PersonSerializer` is found, this method will look\n    for an `App.ApplicationSerializer` (the default serializer for\n    your entire application).\n\n    If no `App.ApplicationSerializer` is found, it will fall back\n    to an instance of `DS.JSONSerializer`.\n\n    @method serializerFor\n    @private\n    @param {String} type the record to serialize\n  */\n  serializerFor: function(type) {\n    type = this.modelFor(type);\n    var adapter = this.adapterFor(type);\n\n    return serializerFor(this.container, type.typeKey, adapter && adapter.defaultSerializer);\n  }\n});\n\nfunction normalizeRelationships(store, type, data, record) {\n  type.eachRelationship(function(key, relationship) {\n    // A link (usually a URL) was already provided in\n    // normalized form\n    if (data.links && data.links[key]) {\n      if (record && relationship.options.async) { record._relationships[key] = null; }\n      return;\n    }\n\n    var kind = relationship.kind,\n        value = data[key];\n\n    if (value == null) { return; }\n\n    if (kind === 'belongsTo') {\n      deserializeRecordId(store, data, key, relationship, value);\n    } else if (kind === 'hasMany') {\n      deserializeRecordIds(store, data, key, relationship, value);\n      addUnsavedRecords(record, key, value);\n    }\n  });\n\n  return data;\n}\n\nfunction deserializeRecordId(store, data, key, relationship, id) {\n  if (isNone(id) || id instanceof DS.Model) {\n    return;\n  }\n\n  var type;\n\n  if (typeof id === 'number' || typeof id === 'string') {\n    type = typeFor(relationship, key, data);\n    data[key] = store.recordForId(type, id);\n  } else if (typeof id === 'object') {\n    // polymorphic\n    data[key] = store.recordForId(id.type, id.id);\n  }\n}\n\nfunction typeFor(relationship, key, data) {\n  if (relationship.options.polymorphic) {\n    return data[key + \"Type\"];\n  } else {\n    return relationship.type;\n  }\n}\n\nfunction deserializeRecordIds(store, data, key, relationship, ids) {\n  for (var i=0, l=ids.length; i<l; i++) {\n    deserializeRecordId(store, ids, i, relationship, ids[i]);\n  }\n}\n\n// If there are any unsaved records that are in a hasMany they won't be\n// in the payload, so add them back in manually.\nfunction addUnsavedRecords(record, key, data) {\n  if(record) {\n    data.pushObjects(record.get(key).filterBy('isNew'));\n  }\n}\n\n// Delegation to the adapter and promise management\n\nDS.PromiseArray = Ember.ArrayProxy.extend(Ember.PromiseProxyMixin);\nDS.PromiseObject = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);\n\nfunction promiseObject(promise) {\n  return DS.PromiseObject.create({ promise: promise });\n}\n\nfunction promiseArray(promise) {\n  return DS.PromiseArray.create({ promise: promise });\n}\n\nfunction isThenable(object) {\n  return object && typeof object.then === 'function';\n}\n\nfunction serializerFor(container, type, defaultSerializer) {\n  return container.lookup('serializer:'+type) ||\n                 container.lookup('serializer:application') ||\n                 container.lookup('serializer:' + defaultSerializer) ||\n                 container.lookup('serializer:_default');\n}\n\nfunction serializerForAdapter(adapter, type) {\n  var serializer = adapter.serializer,\n      defaultSerializer = adapter.defaultSerializer,\n      container = adapter.container;\n\n  if (container && serializer === undefined) {\n    serializer = serializerFor(container, type.typeKey, defaultSerializer);\n  }\n\n  if (serializer === null || serializer === undefined) {\n    serializer = {\n      extract: function(store, type, payload) { return payload; }\n    };\n  }\n\n  return serializer;\n}\n\nfunction _find(adapter, store, type, id, resolver) {\n  var promise = adapter.find(store, type, id),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    Ember.assert(\"You made a request for a \" + type.typeKey + \" with id \" + id + \", but the adapter's response did not have any data\", payload);\n    payload = serializer.extract(store, type, payload, id, 'find');\n\n    return store.push(type, payload);\n  }, function(error) {\n    var record = store.getById(type, id);\n    record.notFound();\n    throw error;\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findMany(adapter, store, type, ids, owner, resolver) {\n  var promise = adapter.findMany(store, type, ids, owner),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findMany');\n\n    Ember.assert(\"The response from a findMany must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    store.pushMany(type, payload);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findHasMany(adapter, store, record, link, relationship, resolver) {\n  var promise = adapter.findHasMany(store, record, link, relationship),\n      serializer = serializerForAdapter(adapter, relationship.type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, relationship.type, payload, null, 'findHasMany');\n\n    Ember.assert(\"The response from a findHasMany must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    var records = store.pushMany(relationship.type, payload);\n    record.updateHasMany(relationship.key, records);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findBelongsTo(adapter, store, record, link, relationship, resolver) {\n  var promise = adapter.findBelongsTo(store, record, link, relationship),\n      serializer = serializerForAdapter(adapter, relationship.type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, relationship.type, payload, null, 'findBelongsTo');\n\n    var record = store.push(relationship.type, payload);\n    record.updateBelongsTo(relationship.key, record);\n    return record;\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findAll(adapter, store, type, sinceToken, resolver) {\n  var promise = adapter.findAll(store, type, sinceToken),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findAll');\n\n    Ember.assert(\"The response from a findAll must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    store.pushMany(type, payload);\n    store.didUpdateAll(type);\n    return store.all(type);\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _findQuery(adapter, store, type, query, recordArray, resolver) {\n  var promise = adapter.findQuery(store, type, query, recordArray),\n      serializer = serializerForAdapter(adapter, type);\n\n  return resolve(promise).then(function(payload) {\n    payload = serializer.extract(store, type, payload, null, 'findAll');\n\n    Ember.assert(\"The response from a findQuery must be an Array, not \" + Ember.inspect(payload), Ember.typeOf(payload) === 'array');\n\n    recordArray.load(payload);\n    return recordArray;\n  }).then(resolver.resolve, resolver.reject);\n}\n\nfunction _commit(adapter, store, operation, record, resolver) {\n  var type = record.constructor,\n      promise = adapter[operation](store, type, record),\n      serializer = serializerForAdapter(adapter, type);\n\n  Ember.assert(\"Your adapter's '\" + operation + \"' method must return a promise, but it returned \" + promise, isThenable(promise));\n\n  return promise.then(function(payload) {\n    if (payload) { payload = serializer.extract(store, type, payload, get(record, 'id'), operation); }\n    store.didSaveRecord(record, payload);\n    return record;\n  }, function(reason) {\n    if (reason instanceof DS.InvalidError) {\n      store.recordWasInvalid(record, reason.errors);\n    } else {\n      store.recordWasError(record, reason);\n    }\n\n    throw reason;\n  }).then(resolver.resolve, resolver.reject);\n}\n\n})();\n//@ sourceURL=ember-data/system/store");