minispade.register('ember-data/system/relationships/belongs_to', "(function() {var get = Ember.get, set = Ember.set,\n    isNone = Ember.isNone;\n\n/**\n  @module ember-data\n*/\n\nfunction asyncBelongsTo(type, options, meta) {\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data'),\n        store = get(this, 'store');\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a '\" + type + \"' record to this relationship\", !value || value instanceof store.modelFor(type));\n      return value === undefined ? null : DS.PromiseObject.create({ promise: Ember.RSVP.resolve(value) });\n    }\n\n    var link = data.links && data.links[key],\n        belongsTo = data[key];\n\n    if(!isNone(belongsTo)) {\n      var promise = store.fetchRecord(belongsTo) || Ember.RSVP.resolve(belongsTo);\n      return DS.PromiseObject.create({promise: promise});\n    } else if (link) {\n      var resolver = Ember.RSVP.defer();\n      store.findBelongsTo(this, link, meta, resolver);\n      return DS.PromiseObject.create({ promise: resolver.promise });\n    } else {\n      return null;\n    }\n  }).property('data').meta(meta);\n}\n\nDS.belongsTo = function(type, options) {\n  if (typeof type === 'object') {\n    options = type;\n    type = undefined;\n  } else {\n    Ember.assert(\"The first argument DS.belongsTo must be a model type or string, like DS.belongsTo(App.Person)\", !!type && (typeof type === 'string' || DS.Model.detect(type)));\n  }\n\n  options = options || {};\n\n  var meta = { type: type, isRelationship: true, options: options, kind: 'belongsTo' };\n\n  if (options.async) {\n    return asyncBelongsTo(type, options, meta);\n  }\n\n  return Ember.computed(function(key, value) {\n    var data = get(this, 'data'),\n        store = get(this, 'store'), belongsTo, typeClass;\n\n    if (typeof type === 'string') {\n      typeClass = store.modelFor(type);\n    } else {\n      typeClass = type;\n    }\n\n    if (arguments.length === 2) {\n      Ember.assert(\"You can only add a '\" + type + \"' record to this relationship\", !value || value instanceof typeClass);\n      return value === undefined ? null : value;\n    }\n\n    belongsTo = data[key];\n\n    if (isNone(belongsTo)) { return null; }\n\n    store.fetchRecord(belongsTo);\n\n    return belongsTo;\n  }).property('data').meta(meta);\n};\n\n/*\n  These observers observe all `belongsTo` relationships on the record. See\n  `relationships/ext` to see how these observers get their dependencies.\n\n  @class Model\n  @namespace DS\n*/\nDS.Model.reopen({\n\n  /**\n    @method belongsToWillChange\n    @private\n    @static\n    @param record\n    @param key\n  */\n  belongsToWillChange: Ember.beforeObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var oldParent = get(record, key);\n\n      if (oldParent) {\n        var store = get(record, 'store'),\n            change = DS.RelationshipChange.createChange(record, oldParent, store, { key: key, kind: \"belongsTo\", changeType: \"remove\" });\n\n        change.sync();\n        this._changesToSync[key] = change;\n      }\n    }\n  }),\n\n  /**\n    @method belongsToDidChange\n    @private\n    @static\n    @param record\n    @param key\n  */\n  belongsToDidChange: Ember.immediateObserver(function(record, key) {\n    if (get(record, 'isLoaded')) {\n      var newParent = get(record, key);\n\n      if (newParent) {\n        var store = get(record, 'store'),\n            change = DS.RelationshipChange.createChange(record, newParent, store, { key: key, kind: \"belongsTo\", changeType: \"add\" });\n\n        change.sync();\n      }\n    }\n\n    delete this._changesToSync[key];\n  })\n});\n\n})();\n//@ sourceURL=ember-data/system/relationships/belongs_to");