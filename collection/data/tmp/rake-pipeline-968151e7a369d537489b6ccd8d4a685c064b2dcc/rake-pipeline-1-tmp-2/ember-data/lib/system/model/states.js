minispade.register('ember-data/system/model/states', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n/*\n  WARNING: Much of these docs are inaccurate as of bf8497.\n\n  This file encapsulates the various states that a record can transition\n  through during its lifecycle.\n\n  ### State Manager\n\n  A record's state manager explicitly tracks what state a record is in\n  at any given time. For instance, if a record is newly created and has\n  not yet been sent to the adapter to be saved, it would be in the\n  `created.uncommitted` state.  If a record has had local modifications\n  made to it that are in the process of being saved, the record would be\n  in the `updated.inFlight` state. (These state paths will be explained\n  in more detail below.)\n\n  Events are sent by the record or its store to the record's state manager.\n  How the state manager reacts to these events is dependent on which state\n  it is in. In some states, certain events will be invalid and will cause\n  an exception to be raised.\n\n  States are hierarchical. For example, a record can be in the\n  `deleted.start` state, then transition into the `deleted.inFlight` state.\n  If a child state does not implement an event handler, the state manager\n  will attempt to invoke the event on all parent states until the root state is\n  reached. The state hierarchy of a record is described in terms of a path\n  string. You can determine a record's current state by getting its manager's\n  current state path:\n\n      record.get('stateManager.currentPath');\n      //=> \"created.uncommitted\"\n\n  The `DS.Model` states are themselves stateless. What we mean is that,\n  though each instance of a record also has a unique instance of a\n  `DS.StateManager`, the hierarchical states that each of *those* points\n  to is a shared data structure. For performance reasons, instead of each\n  record getting its own copy of the hierarchy of states, each state\n  manager points to this global, immutable shared instance. How does a\n  state know which record it should be acting on?  We pass a reference to\n  the current state manager as the first parameter to every method invoked\n  on a state.\n\n  The state manager passed as the first parameter is where you should stash\n  state about the record if needed; you should never store data on the state\n  object itself. If you need access to the record being acted on, you can\n  retrieve the state manager's `record` property. For example, if you had\n  an event handler `myEvent`:\n\n      myEvent: function(manager) {\n        var record = manager.get('record');\n        record.doSomething();\n      }\n\n  For more information about state managers in general, see the Ember.js\n  documentation on `Ember.StateManager`.\n\n  ### Events, Flags, and Transitions\n\n  A state may implement zero or more events, flags, or transitions.\n\n  #### Events\n\n  Events are named functions that are invoked when sent to a record. The\n  state manager will first look for a method with the given name on the\n  current state. If no method is found, it will search the current state's\n  parent, and then its grandparent, and so on until reaching the top of\n  the hierarchy. If the root is reached without an event handler being found,\n  an exception will be raised. This can be very helpful when debugging new\n  features.\n\n  Here's an example implementation of a state with a `myEvent` event handler:\n\n      aState: DS.State.create({\n        myEvent: function(manager, param) {\n          console.log(\"Received myEvent with \"+param);\n        }\n      })\n\n  To trigger this event:\n\n      record.send('myEvent', 'foo');\n      //=> \"Received myEvent with foo\"\n\n  Note that an optional parameter can be sent to a record's `send()` method,\n  which will be passed as the second parameter to the event handler.\n\n  Events should transition to a different state if appropriate. This can be\n  done by calling the state manager's `transitionTo()` method with a path to the\n  desired state. The state manager will attempt to resolve the state path\n  relative to the current state. If no state is found at that path, it will\n  attempt to resolve it relative to the current state's parent, and then its\n  parent, and so on until the root is reached. For example, imagine a hierarchy\n  like this:\n\n      * created\n        * start <-- currentState\n        * inFlight\n      * updated\n        * inFlight\n\n  If we are currently in the `start` state, calling\n  `transitionTo('inFlight')` would transition to the `created.inFlight` state,\n  while calling `transitionTo('updated.inFlight')` would transition to\n  the `updated.inFlight` state.\n\n  Remember that *only events* should ever cause a state transition. You should\n  never call `transitionTo()` from outside a state's event handler. If you are\n  tempted to do so, create a new event and send that to the state manager.\n\n  #### Flags\n\n  Flags are Boolean values that can be used to introspect a record's current\n  state in a more user-friendly way than examining its state path. For example,\n  instead of doing this:\n\n      var statePath = record.get('stateManager.currentPath');\n      if (statePath === 'created.inFlight') {\n        doSomething();\n      }\n\n  You can say:\n\n      if (record.get('isNew') && record.get('isSaving')) {\n        doSomething();\n      }\n\n  If your state does not set a value for a given flag, the value will\n  be inherited from its parent (or the first place in the state hierarchy\n  where it is defined).\n\n  The current set of flags are defined below. If you want to add a new flag,\n  in addition to the area below, you will also need to declare it in the\n  `DS.Model` class.\n\n  #### Transitions\n\n  Transitions are like event handlers but are called automatically upon\n  entering or exiting a state. To implement a transition, just call a method\n  either `enter` or `exit`:\n\n      myState: DS.State.create({\n        // Gets called automatically when entering\n        // this state.\n        enter: function(manager) {\n          console.log(\"Entered myState\");\n        }\n      })\n\n  Note that enter and exit events are called once per transition. If the\n  current state changes, but changes to another child state of the parent,\n  the transition event on the parent will not be triggered.\n*/\n\nvar hasDefinedProperties = function(object) {\n  // Ignore internal property defined by simulated `Ember.create`.\n  var names = Ember.keys(object);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++ ) {\n    name = names[i];\n    if (object.hasOwnProperty(name) && object[name]) { return true; }\n  }\n\n  return false;\n};\n\nvar didSetProperty = function(record, context) {\n  if (context.value === context.originalValue) {\n    delete record._attributes[context.name];\n    record.send('propertyWasReset', context.name);\n  } else if (context.value !== context.oldValue) {\n    record.send('becomeDirty');\n  }\n\n  record.updateRecordArraysLater();\n};\n\n// Implementation notes:\n//\n// Each state has a boolean value for all of the following flags:\n//\n// * isLoaded: The record has a populated `data` property. When a\n//   record is loaded via `store.find`, `isLoaded` is false\n//   until the adapter sets it. When a record is created locally,\n//   its `isLoaded` property is always true.\n// * isDirty: The record has local changes that have not yet been\n//   saved by the adapter. This includes records that have been\n//   created (but not yet saved) or deleted.\n// * isSaving: The record has been committed, but\n//   the adapter has not yet acknowledged that the changes have\n//   been persisted to the backend.\n// * isDeleted: The record was marked for deletion. When `isDeleted`\n//   is true and `isDirty` is true, the record is deleted locally\n//   but the deletion was not yet persisted. When `isSaving` is\n//   true, the change is in-flight. When both `isDirty` and\n//   `isSaving` are false, the change has persisted.\n// * isError: The adapter reported that it was unable to save\n//   local changes to the backend. This may also result in the\n//   record having its `isValid` property become false if the\n//   adapter reported that server-side validations failed.\n// * isNew: The record was created on the client and the adapter\n//   did not yet report that it was successfully saved.\n// * isValid: No client-side validations have failed and the\n//   adapter did not report any server-side validation failures.\n\n// The dirty state is a abstract state whose functionality is\n// shared between the `created` and `updated` states.\n//\n// The deleted state shares the `isDirty` flag with the\n// subclasses of `DirtyState`, but with a very different\n// implementation.\n//\n// Dirty states have three child states:\n//\n// `uncommitted`: the store has not yet handed off the record\n//   to be saved.\n// `inFlight`: the store has handed off the record to be saved,\n//   but the adapter has not yet acknowledged success.\n// `invalid`: the record has invalid information and cannot be\n//   send to the adapter yet.\nvar DirtyState = {\n  initialState: 'uncommitted',\n\n  // FLAGS\n  isDirty: true,\n\n  // SUBSTATES\n\n  // When a record first becomes dirty, it is `uncommitted`.\n  // This means that there are local pending changes, but they\n  // have not yet begun to be saved, and are not invalid.\n  uncommitted: {\n    // EVENTS\n    didSetProperty: didSetProperty,\n\n    propertyWasReset: function(record, name) {\n      var stillDirty = false;\n\n      for (var prop in record._attributes) {\n        stillDirty = true;\n        break;\n      }\n\n      if (!stillDirty) { record.send('rolledBack'); }\n    },\n\n    pushedData: Ember.K,\n\n    becomeDirty: Ember.K,\n\n    willCommit: function(record) {\n      record.transitionTo('inFlight');\n    },\n\n    reloadRecord: function(record, resolver) {\n      get(record, 'store').reloadRecord(record, resolver);\n    },\n\n    rolledBack: function(record) {\n      record.transitionTo('loaded.saved');\n    },\n\n    becameInvalid: function(record) {\n      record.transitionTo('invalid');\n    },\n\n    rollback: function(record) {\n      record.rollback();\n    }\n  },\n\n  // Once a record has been handed off to the adapter to be\n  // saved, it is in the 'in flight' state. Changes to the\n  // record cannot be made during this window.\n  inFlight: {\n    // FLAGS\n    isSaving: true,\n\n    // EVENTS\n    didSetProperty: didSetProperty,\n    becomeDirty: Ember.K,\n    pushedData: Ember.K,\n\n    // TODO: More robust semantics around save-while-in-flight\n    willCommit: Ember.K,\n\n    didCommit: function(record) {\n      var dirtyType = get(this, 'dirtyType');\n\n      record.transitionTo('saved');\n      record.send('invokeLifecycleCallbacks', dirtyType);\n    },\n\n    becameInvalid: function(record, errors) {\n      set(record, 'errors', errors);\n\n      record.transitionTo('invalid');\n      record.send('invokeLifecycleCallbacks');\n    },\n\n    becameError: function(record) {\n      record.transitionTo('uncommitted');\n      record.triggerLater('becameError', record);\n    }\n  },\n\n  // A record is in the `invalid` state when its client-side\n  // invalidations have failed, or if the adapter has indicated\n  // the the record failed server-side invalidations.\n  invalid: {\n    // FLAGS\n    isValid: false,\n\n    // EVENTS\n    deleteRecord: function(record) {\n      record.transitionTo('deleted.uncommitted');\n      record.clearRelationships();\n    },\n\n    didSetProperty: function(record, context) {\n      var errors = get(record, 'errors'),\n          key = context.name;\n\n      set(errors, key, null);\n\n      if (!hasDefinedProperties(errors)) {\n        record.send('becameValid');\n      }\n\n      didSetProperty(record, context);\n    },\n\n    becomeDirty: Ember.K,\n\n    rollback: function(record) {\n      record.send('becameValid');\n      record.send('rollback');\n    },\n\n    becameValid: function(record) {\n      record.transitionTo('uncommitted');\n    },\n\n    invokeLifecycleCallbacks: function(record) {\n      record.triggerLater('becameInvalid', record);\n    }\n  }\n};\n\n// The created and updated states are created outside the state\n// chart so we can reopen their substates and add mixins as\n// necessary.\n\nfunction deepClone(object) {\n  var clone = {}, value;\n\n  for (var prop in object) {\n    value = object[prop];\n    if (value && typeof value === 'object') {\n      clone[prop] = deepClone(value);\n    } else {\n      clone[prop] = value;\n    }\n  }\n\n  return clone;\n}\n\nfunction mixin(original, hash) {\n  for (var prop in hash) {\n    original[prop] = hash[prop];\n  }\n\n  return original;\n}\n\nfunction dirtyState(options) {\n  var newState = deepClone(DirtyState);\n  return mixin(newState, options);\n}\n\nvar createdState = dirtyState({\n  dirtyType: 'created',\n\n  // FLAGS\n  isNew: true\n});\n\ncreatedState.uncommitted.rolledBack = function(record) {\n  record.transitionTo('deleted.saved');\n};\n\nvar updatedState = dirtyState({\n  dirtyType: 'updated'\n});\n\ncreatedState.uncommitted.deleteRecord = function(record) {\n  record.clearRelationships();\n  record.transitionTo('deleted.saved');\n};\n\ncreatedState.uncommitted.rollback = function(record) {\n  DirtyState.uncommitted.rollback.apply(this, arguments);\n  record.transitionTo('deleted.saved');\n};\n\nupdatedState.uncommitted.deleteRecord = function(record) {\n  record.transitionTo('deleted.uncommitted');\n  record.clearRelationships();\n};\n\nvar RootState = {\n  // FLAGS\n  isEmpty: false,\n  isLoading: false,\n  isLoaded: false,\n  isDirty: false,\n  isSaving: false,\n  isDeleted: false,\n  isNew: false,\n  isValid: true,\n\n  // DEFAULT EVENTS\n\n  // Trying to roll back if you're not in the dirty state\n  // doesn't change your state. For example, if you're in the\n  // in-flight state, rolling back the record doesn't move\n  // you out of the in-flight state.\n  rolledBack: Ember.K,\n\n  propertyWasReset: Ember.K,\n\n  // SUBSTATES\n\n  // A record begins its lifecycle in the `empty` state.\n  // If its data will come from the adapter, it will\n  // transition into the `loading` state. Otherwise, if\n  // the record is being created on the client, it will\n  // transition into the `created` state.\n  empty: {\n    isEmpty: true,\n\n    // EVENTS\n    loadingData: function(record, promise) {\n      record._loadingPromise = promise;\n      record.transitionTo('loading');\n    },\n\n    loadedData: function(record) {\n      record.transitionTo('loaded.created.uncommitted');\n\n      record.suspendRelationshipObservers(function() {\n        record.notifyPropertyChange('data');\n      });\n    },\n\n    pushedData: function(record) {\n      record.transitionTo('loaded.saved');\n      record.triggerLater('didLoad');\n    }\n  },\n\n  // A record enters this state when the store askes\n  // the adapter for its data. It remains in this state\n  // until the adapter provides the requested data.\n  //\n  // Usually, this process is asynchronous, using an\n  // XHR to retrieve the data.\n  loading: {\n    // FLAGS\n    isLoading: true,\n\n    exit: function(record) {\n      record._loadingPromise = null;\n    },\n\n    // EVENTS\n    pushedData: function(record) {\n      record.transitionTo('loaded.saved');\n      record.triggerLater('didLoad');\n      set(record, 'isError', false);\n    },\n\n    becameError: function(record) {\n      record.triggerLater('becameError', record);\n    },\n\n    notFound: function(record) {\n      record.transitionTo('empty');\n    }\n  },\n\n  // A record enters this state when its data is populated.\n  // Most of a record's lifecycle is spent inside substates\n  // of the `loaded` state.\n  loaded: {\n    initialState: 'saved',\n\n    // FLAGS\n    isLoaded: true,\n\n    // SUBSTATES\n\n    // If there are no local changes to a record, it remains\n    // in the `saved` state.\n    saved: {\n      setup: function(record) {\n        var attrs = record._attributes,\n            isDirty = false;\n\n        for (var prop in attrs) {\n          if (attrs.hasOwnProperty(prop)) {\n            isDirty = true;\n            break;\n          }\n        }\n\n        if (isDirty) {\n          record.adapterDidDirty();\n        }\n      },\n\n      // EVENTS\n      didSetProperty: didSetProperty,\n\n      pushedData: Ember.K,\n\n      becomeDirty: function(record) {\n        record.transitionTo('updated.uncommitted');\n      },\n\n      willCommit: function(record) {\n        record.transitionTo('updated.inFlight');\n      },\n\n      reloadRecord: function(record, resolver) {\n        get(record, 'store').reloadRecord(record, resolver);\n      },\n\n      deleteRecord: function(record) {\n        record.transitionTo('deleted.uncommitted');\n        record.clearRelationships();\n      },\n\n      unloadRecord: function(record) {\n        // clear relationships before moving to deleted state\n        // otherwise it fails\n        record.clearRelationships();\n        record.transitionTo('deleted.saved');\n      },\n\n      didCommit: function(record) {\n        record.send('invokeLifecycleCallbacks', get(record, 'lastDirtyType'));\n      }\n\n    },\n\n    // A record is in this state after it has been locally\n    // created but before the adapter has indicated that\n    // it has been saved.\n    created: createdState,\n\n    // A record is in this state if it has already been\n    // saved to the server, but there are new local changes\n    // that have not yet been saved.\n    updated: updatedState\n  },\n\n  // A record is in this state if it was deleted from the store.\n  deleted: {\n    initialState: 'uncommitted',\n    dirtyType: 'deleted',\n\n    // FLAGS\n    isDeleted: true,\n    isLoaded: true,\n    isDirty: true,\n\n    // TRANSITIONS\n    setup: function(record) {\n      var store = get(record, 'store');\n\n      store.recordArrayManager.remove(record);\n    },\n\n    // SUBSTATES\n\n    // When a record is deleted, it enters the `start`\n    // state. It will exit this state when the record\n    // starts to commit.\n    uncommitted: {\n\n      // EVENTS\n\n      willCommit: function(record) {\n        record.transitionTo('inFlight');\n      },\n\n      rollback: function(record) {\n        record.rollback();\n      },\n\n      becomeDirty: Ember.K,\n      deleteRecord: Ember.K,\n\n      rolledBack: function(record) {\n        record.transitionTo('loaded.saved');\n      }\n    },\n\n    // After a record starts committing, but\n    // before the adapter indicates that the deletion\n    // has saved to the server, a record is in the\n    // `inFlight` substate of `deleted`.\n    inFlight: {\n      // FLAGS\n      isSaving: true,\n\n      // EVENTS\n\n      // TODO: More robust semantics around save-while-in-flight\n      willCommit: Ember.K,\n      didCommit: function(record) {\n        record.transitionTo('saved');\n\n        record.send('invokeLifecycleCallbacks');\n      },\n\n      becameError: function(record) {\n        record.transitionTo('uncommitted');\n        record.triggerLater('becameError', record);\n      }\n    },\n\n    // Once the adapter indicates that the deletion has\n    // been saved, the record enters the `saved` substate\n    // of `deleted`.\n    saved: {\n      // FLAGS\n      isDirty: false,\n\n      setup: function(record) {\n        var store = get(record, 'store');\n        store.dematerializeRecord(record);\n      },\n\n      invokeLifecycleCallbacks: function(record) {\n        record.triggerLater('didDelete', record);\n        record.triggerLater('didCommit', record);\n      }\n    }\n  },\n\n  invokeLifecycleCallbacks: function(record, dirtyType) {\n    if (dirtyType === 'created') {\n      record.triggerLater('didCreate', record);\n    } else {\n      record.triggerLater('didUpdate', record);\n    }\n\n    record.triggerLater('didCommit', record);\n  }\n};\n\nfunction wireState(object, parent, name) {\n  /*jshint proto:true*/\n  // TODO: Use Object.create and copy instead\n  object = mixin(parent ? Ember.create(parent) : {}, object);\n  object.parentState = parent;\n  object.stateName = name;\n\n  for (var prop in object) {\n    if (!object.hasOwnProperty(prop) || prop === 'parentState' || prop === 'stateName') { continue; }\n    if (typeof object[prop] === 'object') {\n      object[prop] = wireState(object[prop], object, name + \".\" + prop);\n    }\n  }\n\n  return object;\n}\n\nRootState = wireState(RootState, null, \"root\");\n\nDS.RootState = RootState;\n\n})();\n//@ sourceURL=ember-data/system/model/states");