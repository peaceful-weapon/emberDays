minispade.register('ember-data/system/record_arrays/many_array', "(function() {minispade.require(\"ember-data/system/record_arrays/record_array\");\n\n/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar map = Ember.EnumerableUtils.map;\n\n/**\n  A ManyArray is a RecordArray that represents the contents of a has-many\n  relationship.\n\n  The ManyArray is instantiated lazily the first time the relationship is\n  requested.\n\n  ### Inverses\n\n  Often, the relationships in Ember Data applications will have\n  an inverse. For example, imagine the following models are\n  defined:\n\n      App.Post = DS.Model.extend({\n        comments: DS.hasMany('comment')\n      });\n\n      App.Comment = DS.Model.extend({\n        post: DS.belongsTo('post')\n      });\n\n  If you created a new instance of `App.Post` and added\n  a `App.Comment` record to its `comments` has-many\n  relationship, you would expect the comment's `post`\n  property to be set to the post that contained\n  the has-many.\n\n  We call the record to which a relationship belongs the\n  relationship's _owner_.\n\n  @class ManyArray\n  @namespace DS\n  @extends DS.RecordArray\n*/\nDS.ManyArray = DS.RecordArray.extend({\n  init: function() {\n    this._super.apply(this, arguments);\n    this._changesToSync = Ember.OrderedSet.create();\n  },\n\n  /**\n    The record to which this relationship belongs.\n\n    @property {DS.Model}\n    @private\n  */\n  owner: null,\n\n  /**\n    `true` if the relationship is polymorphic, `false` otherwise.\n\n    @property {Boolean}\n    @private\n  */\n  isPolymorphic: false,\n\n  // LOADING STATE\n\n  isLoaded: false,\n\n  loadingRecordsCount: function(count) {\n    this.loadingRecordsCount = count;\n  },\n\n  loadedRecord: function() {\n    this.loadingRecordsCount--;\n    if (this.loadingRecordsCount === 0) {\n      set(this, 'isLoaded', true);\n      this.trigger('didLoad');\n    }\n  },\n\n  fetch: function() {\n    var records = get(this, 'content'),\n        store = get(this, 'store'),\n        owner = get(this, 'owner'),\n        resolver = Ember.RSVP.defer();\n\n    var unloadedRecords = records.filterProperty('isEmpty', true);\n    store.fetchMany(unloadedRecords, owner, resolver);\n  },\n\n  // Overrides Ember.Array's replace method to implement\n  replaceContent: function(index, removed, added) {\n    // Map the array of record objects into an array of  client ids.\n    added = map(added, function(record) {\n      Ember.assert(\"You cannot add '\" + record.constructor.typeKey + \"' records to this relationship (only '\" + this.type.typeKey + \"' allowed)\", !this.type || record instanceof this.type);\n      return record;\n    }, this);\n\n    this._super(index, removed, added);\n  },\n\n  arrangedContentDidChange: function() {\n    Ember.run.once(this, 'fetch');\n  },\n\n  arrayContentWillChange: function(index, removed, added) {\n    var owner = get(this, 'owner'),\n        name = get(this, 'name');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the first half of code that continues inside\n      // of arrayContentDidChange. It gets or creates a change from\n      // the child object, adds the current owner as the old\n      // parent if this is the first time the object was removed\n      // from a ManyArray, and sets `newParent` to null.\n      //\n      // Later, if the object is added to another ManyArray,\n      // the `arrayContentDidChange` will set `newParent` on\n      // the change.\n      for (var i=index; i<index+removed; i++) {\n        var record = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner, record, get(this, 'store'), {\n          parentType: owner.constructor,\n          changeType: \"remove\",\n          kind: \"hasMany\",\n          key: name\n        });\n\n        this._changesToSync.add(change);\n      }\n    }\n\n    return this._super.apply(this, arguments);\n  },\n\n  arrayContentDidChange: function(index, removed, added) {\n    this._super.apply(this, arguments);\n\n    var owner = get(this, 'owner'),\n        name = get(this, 'name'),\n        store = get(this, 'store');\n\n    if (!owner._suspendedRelationships) {\n      // This code is the second half of code that started in\n      // `arrayContentWillChange`. It gets or creates a change\n      // from the child object, and adds the current owner as\n      // the new parent.\n      for (var i=index; i<index+added; i++) {\n        var record = get(this, 'content').objectAt(i);\n\n        var change = DS.RelationshipChange.createChange(owner, record, store, {\n          parentType: owner.constructor,\n          changeType: \"add\",\n          kind:\"hasMany\",\n          key: name\n        });\n        change.hasManyName = name;\n\n        this._changesToSync.add(change);\n      }\n\n      // We wait until the array has finished being\n      // mutated before syncing the OneToManyChanges created\n      // in arrayContentWillChange, so that the array\n      // membership test in the sync() logic operates\n      // on the final results.\n      this._changesToSync.forEach(function(change) {\n        change.sync();\n      });\n\n      this._changesToSync.clear();\n    }\n  },\n\n  // Create a child record within the owner\n  createRecord: function(hash) {\n    var owner = get(this, 'owner'),\n        store = get(owner, 'store'),\n        type = get(this, 'type'),\n        record;\n\n    Ember.assert(\"You cannot add '\" + type.typeKey + \"' records to this polymorphic relationship.\", !get(this, 'isPolymorphic'));\n\n    record = store.createRecord.call(store, type, hash);\n    this.pushObject(record);\n\n    return record;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-data/system/record_arrays/many_array");