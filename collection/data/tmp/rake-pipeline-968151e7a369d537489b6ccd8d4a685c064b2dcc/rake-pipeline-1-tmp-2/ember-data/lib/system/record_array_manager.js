minispade.register('ember-data/system/record_array_manager', "(function() {/**\n  @module ember-data\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar once = Ember.run.once;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n/**\n  @class RecordArrayManager\n  @namespace DS\n  @private\n  @extends Ember.Object\n*/\nDS.RecordArrayManager = Ember.Object.extend({\n  init: function() {\n    this.filteredRecordArrays = Ember.MapWithDefault.create({\n      defaultValue: function() { return []; }\n    });\n\n    this.changedRecords = [];\n  },\n\n  recordDidChange: function(record) {\n    this.changedRecords.push(record);\n    once(this, this.updateRecordArrays);\n  },\n\n  recordArraysForRecord: function(record) {\n    record._recordArrays = record._recordArrays || Ember.OrderedSet.create();\n    return record._recordArrays;\n  },\n\n  /**\n    This method is invoked whenever data is loaded into the store\n    by the adapter or updated by the adapter, or when an attribute\n    changes on a record.\n\n    It updates all filters that a record belongs to.\n\n    To avoid thrashing, it only runs once per run loop per record.\n\n    @method updateRecordArrays\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArrays: function() {\n    forEach(this.changedRecords, function(record) {\n      var type = record.constructor,\n          recordArrays = this.filteredRecordArrays.get(type),\n          filter;\n\n      forEach(recordArrays, function(array) {\n        filter = get(array, 'filterFunction');\n        this.updateRecordArray(array, filter, type, record);\n      }, this);\n\n      // loop through all manyArrays containing an unloaded copy of this\n      // clientId and notify them that the record was loaded.\n      var manyArrays = record._loadingRecordArrays;\n\n      if (manyArrays) {\n        for (var i=0, l=manyArrays.length; i<l; i++) {\n          manyArrays[i].loadedRecord();\n        }\n\n        record._loadingRecordArrays = [];\n      }\n    }, this);\n\n    this.changedRecords = [];\n  },\n\n  /**\n    Update an individual filter.\n\n    @method updateRecordArray\n    @param {DS.FilteredRecordArray} array\n    @param {Function} filter\n    @param {Class} type\n    @param {Number|String} clientId\n  */\n  updateRecordArray: function(array, filter, type, record) {\n    var shouldBeInArray;\n\n    if (!filter) {\n      shouldBeInArray = true;\n    } else {\n      shouldBeInArray = filter(record);\n    }\n\n    var recordArrays = this.recordArraysForRecord(record);\n\n    if (shouldBeInArray) {\n      recordArrays.add(array);\n      array.addRecord(record);\n    } else if (!shouldBeInArray) {\n      recordArrays.remove(array);\n      array.removeRecord(record);\n    }\n  },\n\n  /**\n    When a record is deleted, it is removed from all its\n    record arrays.\n\n    @method remove\n    @param {DS.Model} record\n  */\n  remove: function(record) {\n    var recordArrays = record._recordArrays;\n\n    if (!recordArrays) { return; }\n\n    forEach(recordArrays, function(array) {\n      array.removeRecord(record);\n    });\n  },\n\n  /**\n    This method is invoked if the `filterFunction` property is\n    changed on a `DS.FilteredRecordArray`.\n\n    It essentially re-runs the filter from scratch. This same\n    method is invoked when the filter is created in th first place.\n\n    @method updateFilter\n    @param array\n    @param type\n    @param filter\n  */\n  updateFilter: function(array, type, filter) {\n    var typeMap = this.store.typeMapFor(type),\n        records = typeMap.records, record;\n\n    for (var i=0, l=records.length; i<l; i++) {\n      record = records[i];\n\n      if (!get(record, 'isDeleted') && !get(record, 'isEmpty')) {\n        this.updateRecordArray(array, filter, type, record);\n      }\n    }\n  },\n\n  /**\n    Create a `DS.ManyArray` for a type and list of record references, and index\n    the `ManyArray` under each reference. This allows us to efficiently remove\n    records from `ManyArray`s when they are deleted.\n\n    @method createManyArray\n    @param {Class} type\n    @param {Array} references\n    @return {DS.ManyArray}\n  */\n  createManyArray: function(type, records) {\n    var manyArray = DS.ManyArray.create({\n      type: type,\n      content: records,\n      store: this.store\n    });\n\n    forEach(records, function(record) {\n      var arrays = this.recordArraysForRecord(record);\n      arrays.add(manyArray);\n    }, this);\n\n    return manyArray;\n  },\n\n  /**\n    Register a RecordArray for a given type to be backed by\n    a filter function. This will cause the array to update\n    automatically when records of that type change attribute\n    values or states.\n\n    @method registerFilteredRecordArray\n    @param {DS.RecordArray} array\n    @param {Class} type\n    @param {Function} filter\n  */\n  registerFilteredRecordArray: function(array, type, filter) {\n    var recordArrays = this.filteredRecordArrays.get(type);\n    recordArrays.push(array);\n\n    this.updateFilter(array, type, filter);\n  },\n\n  // Internally, we maintain a map of all unloaded IDs requested by\n  // a ManyArray. As the adapter loads data into the store, the\n  // store notifies any interested ManyArrays. When the ManyArray's\n  // total number of loading records drops to zero, it becomes\n  // `isLoaded` and fires a `didLoad` event.\n  registerWaitingRecordArray: function(record, array) {\n    var loadingRecordArrays = record._loadingRecordArrays || [];\n    loadingRecordArrays.push(array);\n    record._loadingRecordArrays = loadingRecordArrays;\n  }\n});\n\n})();\n//@ sourceURL=ember-data/system/record_array_manager");