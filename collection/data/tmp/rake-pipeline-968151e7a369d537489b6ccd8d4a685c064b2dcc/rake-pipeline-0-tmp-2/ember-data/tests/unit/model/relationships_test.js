minispade.register('ember-data/~tests/unit/model/relationships_test', "(function() {/*global Tag App*/\n\nvar get = Ember.get, set = Ember.set;\n\nmodule(\"unit/model/relationships - DS.Model\");\n\ntest(\"exposes a hash of the relationships on a model\", function() {\n  var Occupation = DS.Model.extend();\n\n  var Person = DS.Model.extend({\n    occupations: DS.hasMany(Occupation)\n  });\n\n  Person.reopen({\n    people: DS.hasMany(Person),\n    parent: DS.belongsTo(Person)\n  });\n\n  var relationships = get(Person, 'relationships');\n  deepEqual(relationships.get(Person), [\n    { name: \"people\", kind: \"hasMany\" },\n    { name: \"parent\", kind: \"belongsTo\" }\n  ]);\n\n  deepEqual(relationships.get(Occupation), [\n    { name: \"occupations\", kind: \"hasMany\" }\n  ]);\n});\n\nvar env;\nmodule(\"unit/model/relationships - DS.hasMany\", {\n  setup: function() {\n    env = setupStore();\n  }\n});\n\ntest(\"hasMany handles pre-loaded relationships\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Pet = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag'),\n    pets: DS.hasMany('pet')\n  });\n\n  env.container.register('model:tag', Tag);\n  env.container.register('model:pet', Pet);\n  env.container.register('model:person', Person);\n\n  env.adapter.find = function(store, type, id) {\n    if (type === Tag && id === '12') {\n      return Ember.RSVP.resolve({ id: 12, name: \"oohlala\" });\n    } else {\n      ok(false, \"find() should not be called with these values\");\n    }\n  };\n\n  var store = env.store;\n\n  store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  store.pushMany('pet', [{ id: 4, name: \"fluffy\" }, { id: 7, name: \"snowy\" }, { id: 12, name: \"cerberus\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [5] });\n  store.push('person', { id: 2, name: \"Yehuda Katz\", tags: [12] });\n\n  var wycats;\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n    var tags = get(person, 'tags');\n    equal(get(tags, 'length'), 1, \"the list of tags should have the correct length\");\n    equal(get(tags.objectAt(0), 'name'), \"friendly\", \"the first tag should be a Tag\");\n\n    store.push('person', { id: 1, name: \"Tom Dale\", tags: [5, 2] });\n    equal(tags, get(person, 'tags'), \"a relationship returns the same object every time\");\n    equal(get(get(person, 'tags'), 'length'), 2, \"the length is updated after new data is loaded\");\n\n    strictEqual(get(person, 'tags').objectAt(0), get(person, 'tags').objectAt(0), \"the returned object is always the same\");\n    asyncEqual(get(person, 'tags').objectAt(0), store.find(Tag, 5), \"relationship objects are the same as objects retrieved directly\");\n\n    store.push('person', { id: 3, name: \"KSelden\" });\n\n    return store.find('person', 3);\n  })).then(async(function(kselden) {\n    equal(get(get(kselden, 'tags'), 'length'), 0, \"a relationship that has not been supplied returns an empty array\");\n\n    store.push('person', { id: 4, name: \"Cyvid Hamluck\", pets: [4] });\n    return store.find('person', 4);\n  })).then(async(function(cyvid) {\n    equal(get(cyvid, 'name'), \"Cyvid Hamluck\", \"precond - retrieves person record from store\");\n\n    var pets = get(cyvid, 'pets');\n    equal(get(pets, 'length'), 1, \"the list of pets should have the correct length\");\n    equal(get(pets.objectAt(0), 'name'), \"fluffy\", \"the first pet should be correct\");\n\n    store.push(Person, { id: 4, name: \"Cyvid Hamluck\", pets: [4, 12] });\n    equal(pets, get(cyvid, 'pets'), \"a relationship returns the same object every time\");\n    equal(get(get(cyvid, 'pets'), 'length'), 2, \"the length is updated after new data is loaded\");\n  }));\n});\n\ntest(\"hasMany lazily loads async relationships\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Pet = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag', { async: true }),\n    pets: DS.hasMany('pet')\n  });\n\n  env.container.register('model:tag', Tag);\n  env.container.register('model:pet', Pet);\n  env.container.register('model:person', Person);\n\n  env.adapter.find = function(store, type, id) {\n    if (type === Tag && id === '12') {\n      return Ember.RSVP.resolve({ id: 12, name: \"oohlala\" });\n    } else {\n      ok(false, \"find() should not be called with these values\");\n    }\n  };\n\n  var store = env.store;\n\n  store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  store.pushMany('pet', [{ id: 4, name: \"fluffy\" }, { id: 7, name: \"snowy\" }, { id: 12, name: \"cerberus\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [5] });\n  store.push('person', { id: 2, name: \"Yehuda Katz\", tags: [12] });\n\n  var wycats;\n\n  store.find('person', 2).then(async(function(person) {\n    wycats = person;\n\n    equal(get(wycats, 'name'), \"Yehuda Katz\", \"precond - retrieves person record from store\");\n\n    return Ember.RSVP.hash({\n      wycats: wycats,\n      tags: wycats.get('tags')\n    });\n  })).then(async(function(records) {\n    equal(get(records.tags, 'length'), 1, \"the list of tags should have the correct length\");\n    equal(get(records.tags.objectAt(0), 'name'), \"oohlala\", \"the first tag should be a Tag\");\n\n    strictEqual(records.tags.objectAt(0), records.tags.objectAt(0), \"the returned object is always the same\");\n    asyncEqual(records.tags.objectAt(0), store.find(Tag, 12), \"relationship objects are the same as objects retrieved directly\");\n\n    return get(wycats, 'tags');\n  })).then(async(function(tags) {\n    var newTag = store.createRecord(Tag);\n    tags.pushObject(newTag);\n  }));\n});\n\ntest(\"should be able to retrieve the type for a hasMany relationship from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  equal(Person.typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a hasMany relationship specified using a string from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  equal(env.store.modelFor('person').typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a belongsTo relationship from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.belongsTo('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  equal(env.store.modelFor('person').typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a belongsTo relationship specified using a string from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.belongsTo('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  equal(env.store.modelFor('person').typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"relationships work when declared with a string path\", function() {\n  window.App = {};\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var env = setupStore({\n    person: Person,\n    tag: Tag\n  });\n\n  env.store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  env.store.push('person', { id: 1, name: \"Tom Dale\", tags: [5, 2] });\n\n  env.store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n    equal(get(person, 'tags.length'), 2, \"the list of tags should have the correct length\");\n  }));\n});\n\ntest(\"hasMany relationships work when the data hash has not been loaded\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag', { async: true })\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  env.adapter.findMany = function(store, type, ids) {\n    equal(type, Tag, \"type should be Tag\");\n    deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n\n    return Ember.RSVP.resolve([{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  };\n\n  env.adapter.find = function(store, type, id) {\n    equal(type, Person, \"type should be Person\");\n    equal(id, 1, \"id should be 1\");\n\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", tags: [5, 2] });\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n\n    return person.get('tags');\n  })).then(async(function(tags) {\n    equal(get(tags, 'length'), 2, \"the tags object still exists\");\n    equal(get(tags.objectAt(0), 'name'), \"friendly\", \"Tom Dale is now friendly\");\n    equal(get(tags.objectAt(0), 'isLoaded'), true, \"Tom Dale is now loaded\");\n  }));\n});\n\ntest(\"it is possible to add a new item to a relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    people: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({\n    tag: Tag,\n    person: Person\n  });\n\n  var store = env.store;\n\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [ 1 ] });\n  store.push('tag', { id: 1, name: \"ember\" });\n\n  store.find(Person, 1).then(async(function(person) {\n    var tag = get(person, 'tags').objectAt(0);\n\n    equal(get(tag, 'name'), \"ember\", \"precond - relationships work\");\n\n    tag = store.createRecord(Tag, { name: \"js\" });\n    get(person, 'tags').pushObject(tag);\n\n    equal(get(person, 'tags').objectAt(1), tag, \"newly added relationship works\");\n  }));\n});\n\ntest(\"it is possible to remove an item from a relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.push('person', { id: 1, name: \"Tom Dale\", tags: [ 1 ] });\n  store.push('tag', { id: 1, name: \"ember\" });\n\n  store.find('person', 1).then(async(function(person) {\n    var tag = get(person, 'tags').objectAt(0);\n\n    equal(get(tag, 'name'), \"ember\", \"precond - relationships work\");\n\n    get(person, 'tags').removeObject(tag);\n\n    equal(get(person, 'tags.length'), 0, \"object is removed from the relationship\");\n  }));\n});\n\ntest(\"it is possible to add an item to a relationship, remove it, then add it again\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  Tag.toString = function() { return \"Tag\"; };\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  var person = store.createRecord('person');\n  var tag1 = store.createRecord('tag');\n  var tag2 = store.createRecord('tag');\n  var tag3 = store.createRecord('tag');\n\n  var tags = get(person, 'tags');\n\n  tags.pushObjects([tag1, tag2, tag3]);\n  tags.removeObject(tag2);\n  equal(tags.objectAt(0), tag1);\n  equal(tags.objectAt(1), tag3);\n  equal(get(person, 'tags.length'), 2, \"object is removed from the relationship\");\n\n  tags.insertAt(0, tag2);\n  equal(get(person, 'tags.length'), 3, \"object is added back to the relationship\");\n  equal(tags.objectAt(0), tag2);\n  equal(tags.objectAt(1), tag1);\n  equal(tags.objectAt(2), tag3);\n});\n\nmodule(\"unit/model/relationships - RecordArray\");\n\ntest(\"updating the content of a RecordArray updates its content\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var env = setupStore({ tag: Tag }),\n      store = env.store;\n\n  var records = store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n\n  var tags = DS.RecordArray.create({ content: Ember.A(records.slice(0, 2)), store: store, type: Tag });\n\n  var tag = tags.objectAt(0);\n  equal(get(tag, 'name'), \"friendly\", \"precond - we're working with the right tags\");\n\n  set(tags, 'content', Ember.A(records.slice(1, 3)));\n  tag = tags.objectAt(0);\n  equal(get(tag, 'name'), \"smarmy\", \"the lookup was updated\");\n});\n\ntest(\"can create child record from a hasMany relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('tag')\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.push('person', { id: 1, name: \"Tom Dale\"});\n\n  store.find('person', 1).then(async(function(person) {\n    person.get(\"tags\").createRecord({ name: \"cool\" });\n\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n    equal(get(person, 'tags.length'), 1, \"tag is added to the parent record\");\n    equal(get(person, 'tags').objectAt(0).get(\"name\"), \"cool\", \"tag values are passed along\");\n  }));\n});\n\nmodule(\"unit/model/relationships - DS.belongsTo\");\n\ntest(\"belongsTo lazily loads relationships as needed\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    people: DS.hasMany('person')\n  });\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag')\n  });\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.pushMany('tag', [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tag: 5 });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n    equal(get(person, 'tag') instanceof Tag, true, \"the tag property should return a tag\");\n    equal(get(person, 'tag.name'), \"friendly\", \"the tag shuld have name\");\n\n    strictEqual(get(person, 'tag'), get(person, 'tag'), \"the returned object is always the same\");\n    asyncEqual(get(person, 'tag'), store.find('tag', 5), \"relationship object is the same as object retrieved directly\");\n  }));\n});\n\ntest(\"async belongsTo relationships work when the data hash has not been loaded\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag', { async: true })\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  env.adapter.find = function(store, type, id) {\n    if (type === Person) {\n      equal(id, 1, \"id should be 1\");\n\n      return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", tag: 2 });\n    } else if (type === Tag) {\n      equal(id, 2, \"id should be 2\");\n\n      return Ember.RSVP.resolve({ id: 2, name: \"friendly\" });\n    }\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n\n    return get(person, 'tag');\n  })).then(async(function(tag) {\n    equal(get(tag, 'name'), \"friendly\", \"Tom Dale is now friendly\");\n    equal(get(tag, 'isLoaded'), true, \"Tom Dale is now loaded\");\n  }));\n});\n\ntest(\"async belongsTo relationships work when the data hash has already been loaded\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag', { async: true })\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n    store.push('tag', { id: 2, name: \"friendly\"});\n    store.push('person', { id: 1, name: \"Tom Dale\", tag: 2});\n\n    store.find('person', 1).then(async(function(person) {\n        equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n        return get(person, 'tag');\n    })).then(async(function(tag) {\n        equal(get(tag, 'name'), \"friendly\", \"Tom Dale is now friendly\");\n        equal(get(tag, 'isLoaded'), true, \"Tom Dale is now loaded\");\n  }));\n});\n\ntest(\"calling createRecord and passing in an undefined value for a relationship should be treated as if null\", function () {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag')\n  });\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.createRecord('person', {id: 1, tag: undefined});\n\n  store.find(Person, 1).then(async(function(person) {\n    strictEqual(person.get('tag'), null, \"undefined values should return null relationships\");\n  }));\n});\n\ntest(\"findMany is passed the owner record for adapters when some of the object graph is already loaded\", function() {\n  var Occupation = DS.Model.extend({\n    description: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  Occupation.toString = function() { return \"Occupation\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    occupations: DS.hasMany('occupation', { async: true })\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ occupation: Occupation, person: Person }),\n      store = env.store;\n\n  env.adapter.findMany = function(store, type, ids, owner) {\n    equal(type, Occupation, \"type should be Occupation\");\n    deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n    equal(get(owner, 'id'), 1, \"the owner record id should be 1\");\n\n    return Ember.RSVP.resolve([{ id: 5, description: \"fifth\" }, { id: 2, description: \"second\" }]);\n  };\n\n  store.push('person', { id: 1, name: \"Tom Dale\", occupations: [5, 2] });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'isLoaded'), true, \"isLoaded should be true\");\n    equal(get(person, 'name'), \"Tom Dale\", \"the person is still Tom Dale\");\n\n    return get(person, 'occupations');\n  })).then(async(function(occupations) {\n    equal(get(occupations, 'length'), 2, \"the list of occupations should have the correct length\");\n\n    equal(get(occupations.objectAt(0), 'description'), \"fifth\", \"the occupation is the fifth\");\n    equal(get(occupations.objectAt(0), 'isLoaded'), true, \"the occupation is now loaded\");\n  }));\n});\n\ntest(\"findMany is passed the owner record for adapters when none of the object graph is loaded\", function() {\n  var Occupation = DS.Model.extend({\n    description: DS.attr('string'),\n    person: DS.belongsTo('person')\n  });\n\n  Occupation.toString = function() { return \"Occupation\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    occupations: DS.hasMany('occupation', { async: true })\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ occupation: Occupation, person: Person }),\n      store = env.store;\n\n  env.adapter.findMany = function(store, type, ids, owner) {\n    equal(type, Occupation, \"type should be Occupation\");\n    deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n    equal(get(owner, 'id'), 1, \"the owner record id should be 1\");\n\n    return Ember.RSVP.resolve([{ id: 5, description: \"fifth\" }, { id: 2, description: \"second\" }]);\n  };\n\n  env.adapter.find = function(store, type, id) {\n    equal(type, Person, \"type should be Person\");\n    equal(id, 1, \"id should be 1\");\n\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", occupations: [5, 2] });\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n\n    return get(person, 'occupations');\n  })).then(async(function(occupations) {\n    equal(get(occupations, 'length'), 2, \"the occupation objects still exist\");\n    equal(get(occupations.objectAt(0), 'description'), \"fifth\", \"the occupation is the fifth\");\n    equal(get(occupations.objectAt(0), 'isLoaded'), true, \"the occupation is now loaded\");\n  }));\n});\n\ntest(\"belongsTo supports relationships to models with id 0\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string'),\n    people: DS.hasMany('person')\n  });\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo('tag')\n  });\n  Person.toString = function() { return \"Person\"; };\n\n  var env = setupStore({ tag: Tag, person: Person }),\n      store = env.store;\n\n  store.pushMany('tag', [{ id: 0, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  store.push('person', { id: 1, name: \"Tom Dale\", tag: 0 });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n    equal(get(person, 'tag') instanceof Tag, true, \"the tag property should return a tag\");\n    equal(get(person, 'tag.name'), \"friendly\", \"the tag shuld have name\");\n\n    strictEqual(get(person, 'tag'), get(person, 'tag'), \"the returned object is always the same\");\n    asyncEqual(get(person, 'tag'), store.find(Tag, 0), \"relationship object is the same as object retrieved directly\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/model/relationships_test");