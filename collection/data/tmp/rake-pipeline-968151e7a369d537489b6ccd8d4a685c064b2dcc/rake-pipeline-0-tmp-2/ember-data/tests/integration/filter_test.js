minispade.register('ember-data/~tests/integration/filter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\nvar Person, store, env, array, recordArray;\n\nvar shouldContain = function(array, item) {\n  ok(indexOf(array, item) !== -1, \"array should contain \"+item.get('name'));\n};\n\nvar shouldNotContain = function(array, item) {\n  ok(indexOf(array, item) === -1, \"array should not contain \"+item.get('name'));\n};\n\nmodule(\"integration/filter - DS.Model updating\", {\n  setup: function() {\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({ name: DS.attr('string') });\n\n    env = setupStore({ person: Person });\n    store = env.store;\n  },\n  teardown: function() {\n    store.destroy();\n    Person = null;\n    array = null;\n  }\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  store.pushMany('person', array);\n\n  var people = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\ntest(\"a record array can have a filter on it\", function() {\n  store.pushMany('person', array);\n\n  var recordArray = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array should have the filtered objects on it\");\n\n  store.push('person', { id: 4, name: \"Scumbag Koz\" });\n\n  equal(get(recordArray, 'length'), 3, \"The Record Array should be updated as new items are added to the store\");\n\n  store.push('person', { id: 1, name: \"Scumbag Tom\" });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array should be updated as existing members are updated\");\n});\n\ntest(\"a filtered record array includes created elements\", function() {\n  store.pushMany('person', array);\n\n  var recordArray = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 2, \"precond - The Record Array should have the filtered objects on it\");\n\n  store.createRecord('person', { name: \"Scumbag Koz\" });\n\n  equal(get(recordArray, 'length'), 3, \"The record array has the new object on it\");\n});\n\ntest(\"a Record Array can update its filter\", function() {\n  set(store, 'adapter', DS.Adapter.extend({\n    deleteRecord: function(store, type, record) {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  store.pushMany('person', array);\n\n  var dickens = store.createRecord('person', { id: 4, name: \"Scumbag Dickens\" });\n  dickens.deleteRecord();\n\n  var asyncDale = store.find('person', 1);\n  var asyncKatz = store.find('person', 2);\n  var asyncBryn = store.find('person', 3);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  Ember.RSVP.hash({ dale: asyncDale, katz: asyncKatz, bryn: asyncBryn }).then(async(function(records) {\n    shouldContain(recordArray, records.dale);\n    shouldContain(recordArray, records.katz);\n    shouldNotContain(recordArray, records.bryn);\n    shouldNotContain(recordArray, dickens);\n\n    recordArray.set('filterFunction', function(hash) {\n      if (hash.get('name').match(/Katz/)) { return true; }\n    });\n\n    equal(get(recordArray, 'length'), 1, \"The Record Array should have one object on it\");\n\n    Ember.run(function() {\n      store.push('person', { id: 5, name: \"Other Katz\" });\n    });\n\n    equal(get(recordArray, 'length'), 2, \"The Record Array now has the new object matching the filter\");\n\n    Ember.run(function() {\n      store.push('person', { id: 6, name: \"Scumbag Demon\" });\n    });\n\n    equal(get(recordArray, 'length'), 2, \"The Record Array doesn't have objects matching the old filter\");\n  }));\n});\n\ntest(\"a Record Array can update its filter and notify array observers\", function() {\n  set(store, 'adapter', DS.Adapter.extend({\n    deleteRecord: function(store, type, record) {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  store.pushMany('person', array);\n\n  var dickens = store.createRecord('person', { id: 4, name: \"Scumbag Dickens\" });\n  dickens.deleteRecord();\n\n  var asyncDale = store.find('person', 1);\n  var asyncKatz = store.find('person', 2);\n  var asyncBryn = store.find('person', 3);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  var didChangeIdx, didChangeRemoved = 0, didChangeAdded = 0;\n\n  var arrayObserver = {\n    arrayWillChange: Ember.K,\n\n    arrayDidChange: function(array, idx, removed, added) {\n      didChangeIdx = idx;\n      didChangeRemoved += removed;\n      didChangeAdded += added;\n    }\n  };\n\n  recordArray.addArrayObserver(arrayObserver);\n\n  recordArray.set('filterFunction', function(hash) {\n    if (hash.get('name').match(/Katz/)) { return true; }\n  });\n\n  Ember.RSVP.all([ asyncDale, asyncKatz, asyncBryn ]).then(async(function() {\n    equal(didChangeRemoved, 1, \"removed one item from array\");\n    didChangeRemoved = 0;\n\n    Ember.run(function() {\n      store.push('person', { id: 5, name: \"Other Katz\" });\n    });\n\n    equal(didChangeAdded, 1, \"one item was added\");\n    didChangeAdded = 0;\n\n    equal(recordArray.objectAt(didChangeIdx).get('name'), \"Other Katz\");\n\n    Ember.run(function() {\n      store.push('person', { id: 6, name: \"Scumbag Demon\" });\n    });\n\n    equal(didChangeAdded, 0, \"did not get called when an object that doesn't match is added\");\n\n    Ember.run(function() {\n      recordArray.set('filterFunction', function(hash) {\n        if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n      });\n    });\n\n    equal(didChangeAdded, 2, \"one item is added when going back\");\n    equal(recordArray.objectAt(didChangeIdx).get('name'), \"Scumbag Demon\");\n    equal(recordArray.objectAt(didChangeIdx-1).get('name'), \"Scumbag Dale\");\n  }));\n});\n\ntest(\"it is possible to filter by computed properties\", function() {\n  Person.reopen({\n    name: DS.attr('string'),\n    upperName: Ember.computed(function() {\n      return this.get('name').toUpperCase();\n    }).property('name')\n  });\n\n  var filter = store.filter('person', function(person) {\n    return person.get('upperName') === \"TOM DALE\";\n  });\n\n  equal(filter.get('length'), 0, \"precond - the filter starts empty\");\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  equal(filter.get('length'), 1, \"the filter now has a record in it\");\n\n  store.find('person', 1).then(async(function(person) {\n    Ember.run(function() {\n      person.set('name', \"Yehuda Katz\");\n    });\n\n    equal(filter.get('length'), 0, \"the filter is empty again\");\n  }));\n});\n\ntest(\"a filter created after a record is already loaded works\", function() {\n  Person.reopen({\n    name: DS.attr('string'),\n    upperName: Ember.computed(function() {\n      return this.get('name').toUpperCase();\n    }).property('name')\n  });\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  var filter = store.filter('person', function(person) {\n    return person.get('upperName') === \"TOM DALE\";\n  });\n\n  equal(filter.get('length'), 1, \"the filter now has a record in it\");\n  asyncEqual(filter.objectAt(0), store.find('person', 1));\n});\n\ntest(\"it is possible to filter by state flags\", function() {\n  set(store, 'adapter', DS.Adapter.extend({\n    find: function(store, type, id) {\n      return Ember.RSVP.resolve({ id: id, name: \"Tom Dale\" });\n    }\n  }));\n\n  var filter = store.filter(Person, function(person) {\n    return person.get('isLoaded');\n  });\n\n  equal(filter.get('length'), 0, \"precond - there are no records yet\");\n\n  Ember.run(function() {\n    var asyncPerson = store.find('person', 1);\n\n    // Ember.run will block `find` from being synchronously\n    // resolved in test mode\n\n    equal(filter.get('length'), 0, \"the unloaded record isn't in the filter\");\n\n    asyncPerson.then(async(function(person) {\n      equal(filter.get('length'), 1, \"the now-loaded record is in the filter\");\n      asyncEqual(filter.objectAt(0), store.find('person', 1));\n    }));\n  });\n});\n\ntest(\"it is possible to filter loaded records by dirtiness\", function() {\n  set(store, 'adapter', DS.Adapter.extend({\n    updateRecord: function() {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  var filter = store.filter('person', function(person) {\n    return !person.get('isDirty');\n  });\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n\n  store.find('person', 1).then(async(function(person) {\n    equal(filter.get('length'), 1, \"the clean record is in the filter\");\n\n    // Force synchronous update of the filter, even though\n    // we're already inside a run loop\n    Ember.run(function() {\n      person.set('name', \"Yehuda Katz\");\n    });\n\n    equal(filter.get('length'), 0, \"the now-dirty record is not in the filter\");\n\n    return person.save();\n  })).then(async(function(person) {\n    equal(filter.get('length'), 1, \"the clean record is back in the filter\");\n  }));\n});\n\ntest(\"it is possible to filter created records by dirtiness\", function() {\n  set(store, 'adapter', DS.Adapter.extend({\n    createRecord: function() {\n      return Ember.RSVP.resolve();\n    }\n  }));\n\n  var filter = store.filter('person', function(person) {\n    return !person.get('isDirty');\n  });\n\n  var person = store.createRecord('person', {\n    id: 1,\n    name: \"Tom Dale\"\n  });\n\n  equal(filter.get('length'), 0, \"the dirty record is not in the filter\");\n\n  person.save().then(async(function(person) {\n    equal(filter.get('length'), 1, \"the clean record is in the filter\");\n  }));\n});\n\n\n// SERVER SIDE TESTS\nvar edited;\n\nvar clientEdits = function(ids) {\n  edited = [];\n\n  forEach(ids, function(id) {\n    // wrap in an Ember.run to guarantee coalescence of the\n    // iterated `set` calls and promise resolution.\n    Ember.run(function() {\n      store.find('person', id).then(function(person) {\n        edited.push(person);\n        person.set('name', 'Client-side ' + id );\n      });\n    });\n  });\n};\n\nvar clientCreates = function(names) {\n  edited = [];\n\n  // wrap in an Ember.run to guarantee coalescence of the\n  // iterated `set` calls.\n  Ember.run( function() {\n    forEach(names, function( name ) {\n      edited.push(store.createRecord('person', { name: 'Client-side ' + name }));\n    });\n  });\n};\n\nvar serverResponds = function(){\n  forEach(edited, function(person) { person.save(); });\n};\n\nvar setup = function(serverCallbacks) {\n  set(store, 'adapter', DS.Adapter.extend(serverCallbacks));\n\n  store.pushMany('person', array);\n\n  recordArray = store.filter('person', function(hash) {\n    if (hash.get('name').match(/Scumbag/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 3, \"The filter function should work\");\n};\n\ntest(\"a Record Array can update its filter after server-side updates one record\", function() {\n  setup({\n    updateRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({id: 1, name: \"Scumbag Server-side Dale\"});\n    }\n  });\n\n  clientEdits([1]);\n  equal(get(recordArray, 'length'), 2, \"The record array updates when the client changes records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 3, \"The record array updates when the server changes one record\");\n});\n\ntest(\"a Record Array can update its filter after server-side updates multiple records\", function() {\n  setup({\n    updateRecord: function(store, type, record) {\n      switch (record.get('id')) {\n        case \"1\":\n          return Ember.RSVP.resolve({ id: 1, name: \"Scumbag Server-side Dale\" });\n        case \"2\":\n          return Ember.RSVP.resolve({ id: 2, name: \"Scumbag Server-side Katz\" });\n      }\n    }\n  });\n\n  clientEdits([1,2]);\n  equal(get(recordArray, 'length'), 1, \"The record array updates when the client changes records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 3, \"The record array updates when the server changes multiple records\");\n});\n\ntest(\"a Record Array can update its filter after server-side creates one record\", function() {\n  setup({\n    createRecord: function(store, type, record) {\n      return Ember.RSVP.resolve({id: 4, name: \"Scumbag Server-side Tim\"});\n    }\n  });\n\n  clientCreates([\"Tim\"]);\n  equal(get(recordArray, 'length'), 3, \"The record array does not include non-matching records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 4, \"The record array updates when the server creates a record\");\n});\n\ntest(\"a Record Array can update its filter after server-side creates multiple records\", function() {\n  setup({\n    createRecord: function(store, type, record) {\n      switch (record.get('name')) {\n        case \"Client-side Mike\":\n          return Ember.RSVP.resolve({id: 4, name: \"Scumbag Server-side Mike\"});\n        case \"Client-side David\":\n          return Ember.RSVP.resolve({id: 5, name: \"Scumbag Server-side David\"});\n      }\n    }\n  });\n\n  clientCreates([\"Mike\", \"David\"]);\n  equal(get(recordArray, 'length'), 3, \"The record array does not include non-matching records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 5, \"The record array updates when the server creates multiple records\");\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/filter_test");