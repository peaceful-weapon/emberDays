minispade.register('ember-data/~tests/integration/relationships/has_many_test', "(function() {var env, User, Contact, Email, Phone, Message, Post, Comment;\nvar get = Ember.get, set = Ember.set;\n\nvar attr = DS.attr, hasMany = DS.hasMany, belongsTo = DS.belongsTo;\n\nfunction stringify(string) {\n  return function() { return string; };\n}\n\nmodule(\"integration/relationships/has_many - Has-Many Relationships\", {\n  setup: function() {\n    User = DS.Model.extend({\n      name: attr('string'),\n      messages: hasMany('message', { polymorphic: true }),\n      contacts: hasMany()\n    });\n\n    Contact = DS.Model.extend({\n      user: belongsTo('user')\n    });\n\n    Email = Contact.extend({\n      email: attr('string')\n    });\n\n    Phone = Contact.extend({\n      number: attr('string')\n    });\n\n    Message = DS.Model.extend({\n      user: belongsTo('user'),\n      created_at: attr('date')\n    });\n    Message.toString = stringify('Message');\n\n    Post = Message.extend({\n      title: attr('string'),\n      comments: hasMany('comment')\n    });\n    Post.toString = stringify('Post');\n\n    Comment = Message.extend({\n      body: DS.attr('string'),\n      message: DS.belongsTo('post', { polymorphic: true })\n    });\n    Comment.toString = stringify('Comment');\n\n    env = setupStore({\n      user: User,\n      contact: Contact,\n      email: Email,\n      phone: Phone,\n      post: Post,\n      comment: Comment,\n      message: Message\n    });\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"When a hasMany relationship is accessed, the adapter's findMany method should not be called if all the records in the relationship are already loaded\", function() {\n  expect(0);\n\n  env.adapter.findMany = function() {\n    ok(false, \"The adapter's find method should not be called\");\n  };\n\n  env.store.push('post', { id: 1, comments: [ 1 ] });\n  env.store.push('comment', { id: 1 });\n\n  env.store.find('post', 1).then(async(function(post) {\n    post.get('comments');\n  }));\n});\n\n// This tests the case where a serializer materializes a has-many\n// relationship as a reference that it can fetch lazily. The most\n// common use case of this is to provide a URL to a collection that\n// is loaded later.\ntest(\"A serializer can materialize a hasMany as an opaque token that can be lazily fetched via the adapter's findHasMany hook\", function() {\n  Post.reopen({\n    comments: DS.hasMany('comment', { async: true })\n  });\n\n  // When the store asks the adapter for the record with ID 1,\n  // provide some fake data.\n  env.adapter.find = function(store, type, id) {\n    equal(type, Post, \"find type was Post\");\n    equal(id, \"1\", \"find id was 1\");\n\n    return Ember.RSVP.resolve({ id: 1, links: { comments: \"/posts/1/comments\" } });\n  };\n\n  env.adapter.findMany = function() {\n    throw new Error(\"Adapter's findMany should not be called\");\n  };\n\n  env.adapter.findHasMany = function(store, record, link, relationship) {\n    equal(relationship.type, Comment, \"findHasMany relationship type was Comment\");\n    equal(relationship.key, 'comments', \"findHasMany relationship key was comments\");\n    equal(link, \"/posts/1/comments\", \"findHasMany link was /posts/1/comments\");\n\n    return Ember.RSVP.resolve([\n      { id: 1, body: \"First\" },\n      { id: 2, body: \"Second\" }\n    ]);\n  };\n\n  env.store.find('post', 1).then(async(function(post) {\n    return post.get('comments');\n  })).then(async(function(comments) {\n    equal(comments.get('isLoaded'), true, \"comments are loaded\");\n    equal(comments.get('length'), 2, \"comments have 2 length\");\n  }));\n});\n\ntest(\"An updated `links` value should invalidate a relationship cache\", function() {\n  Post.reopen({\n    comments: DS.hasMany('comment', { async: true })\n  });\n\n  env.adapter.createRecord = function(store, type, record) {\n    var data = record.serialize();\n    return Ember.RSVP.resolve({ id: 1, links: { comments: \"/posts/1/comments\" } });\n  };\n\n  env.adapter.findHasMany = function(store, record, link, relationship) {\n    equal(relationship.type, Comment, \"findHasMany relationship type was Comment\");\n    equal(relationship.key, 'comments', \"findHasMany relationship key was comments\");\n    equal(link, \"/posts/1/comments\", \"findHasMany link was /posts/1/comments\");\n\n    return Ember.RSVP.resolve([\n      { id: 1, body: \"First\" },\n      { id: 2, body: \"Second\" }\n    ]);\n  };\n\n  env.store.createRecord('post', {}).save().then(async(function(post) {\n    return post.get('comments');\n  })).then(async(function(comments) {\n    equal(comments.get('isLoaded'), true, \"comments are loaded\");\n    equal(comments.get('length'), 2, \"comments have 2 length\");\n  }));\n});\n\ntest(\"When a polymorphic hasMany relationship is accessed, the adapter's findMany method should not be called if all the records in the relationship are already loaded\", function() {\n  expect(1);\n\n  env.adapter.findMany = function() {\n    ok(false, \"The adapter's find method should not be called\");\n  };\n\n  env.store.push('user', { id: 1, messages: [ {id: 1, type: 'post'}, {id: 3, type: 'comment'} ] });\n  env.store.push('post', { id: 1 });\n  env.store.push('comment', { id: 3 });\n\n  env.store.find('user', 1).then(async(function(user) {\n    var messages = user.get('messages');\n    equal(messages.get('length'), 2, \"The messages are correctly loaded\");\n  }));\n});\n\ntest(\"When a polymorphic hasMany relationship is accessed, the store can call multiple adapters' findMany method if the records are not loaded\", function() {\n  User.reopen({\n    messages: hasMany('message', { polymorphic: true, async: true })\n  });\n\n  env.adapter.findMany = function(store, type) {\n    if (type === Post) {\n      return Ember.RSVP.resolve([{ id: 1 }]);\n    } else if (type === Comment) {\n      return Ember.RSVP.resolve([{ id: 3 }]);\n    }\n  };\n\n  env.store.push('user', { id: 1, messages: [ {id: 1, type: 'post'}, {id: 3, type: 'comment'} ] });\n\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('messages');\n  })).then(async(function(messages) {\n    equal(messages.get('length'), 2, \"The messages are correctly loaded\");\n  }));\n});\n\ntest(\"Type can be inferred from the key of a hasMany relationship\", function() {\n  expect(1);\n  env.store.push('user', { id: 1, contacts: [ 1 ] });\n  env.store.push('contact', { id: 1 });\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('contacts');\n  })).then(async(function(contacts) {\n    equal(contacts.get('length'), 1, \"The contacts relationship is correctly set up\");\n  }));\n});\n\ntest(\"Type can be inferred from the key of an async hasMany relationship\", function() {\n  User.reopen({\n    contacts: DS.hasMany({ async: true })\n  });\n\n  expect(1);\n  env.store.push('user', { id: 1, contacts: [ 1 ] });\n  env.store.push('contact', { id: 1 });\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('contacts');\n  })).then(async(function(contacts) {\n    equal(contacts.get('length'), 1, \"The contacts relationship is correctly set up\");\n  }));\n});\n\ntest(\"Polymorphic relationships work with a hasMany whose type is inferred\", function() {\n  User.reopen({\n    contacts: DS.hasMany({ polymorphic: true })\n  });\n\n  expect(1);\n  env.store.push('user', { id: 1, contacts: [ { id: 1, type: 'email' }, { id: 2, type: 'phone' } ] });\n  env.store.push('email', { id: 1 });\n  env.store.push('phone', { id: 2 });\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('contacts');\n  })).then(async(function(contacts) {\n    equal(contacts.get('length'), 2, \"The contacts relationship is correctly set up\");\n  }));\n});\n\ntest(\"A record can't be created from a polymorphic hasMany relationship\", function() {\n  env.store.push('user', { id: 1, messages: [] });\n\n  env.store.find('user', 1).then(async(function(user) {\n    return user.get('messages');\n  })).then(async(function(messages) {\n    expectAssertion(function() {\n      messages.createRecord();\n    }, /You cannot add 'message' records to this polymorphic relationship/);\n  }));\n});\n\ntest(\"Only records of the same type can be added to a monomorphic hasMany relationship\", function() {\n  expect(1);\n  env.store.push('post', { id: 1, comments: [] });\n  env.store.push('post', { id: 2 });\n\n  Ember.RSVP.all([ env.store.find('post', 1), env.store.find('post', 2) ]).then(async(function(records) {\n    expectAssertion(function() {\n      records[0].get('comments').pushObject(records[1]);\n    }, /You cannot add 'post' records to this relationship/);\n  }));\n\n});\n\ntest(\"Only records of the same base type can be added to a polymorphic hasMany relationship\", function() {\n  expect(2);\n  env.store.push('user', { id: 1, messages: [] });\n  env.store.push('user', { id: 2, messages: [] });\n  env.store.push('post', { id: 1, comments: [] });\n  env.store.push('comment', { id: 3 });\n\n  var asyncRecords = Ember.RSVP.hash({\n    user: env.store.find('user', 1),\n    anotherUser: env.store.find('user', 2),\n    post: env.store.find('post', 1),\n    comment: env.store.find('comment', 3)\n  });\n\n  asyncRecords.then(async(function(records) {\n    records.messages = records.user.get('messages');\n    return Ember.RSVP.hash(records);\n  })).then(async(function(records) {\n    records.messages.pushObject(records.post);\n    records.messages.pushObject(records.comment);\n    equal(records.messages.get('length'), 2, \"The messages are correctly added\");\n\n    expectAssertion(function() {\n      records.messages.pushObject(records.anotherUser);\n    }, /You cannot add 'user' records to this relationship/);\n  }));\n});\n\ntest(\"A record can be removed from a polymorphic association\", function() {\n  expect(3);\n\n  env.store.push('user', { id: 1 , messages: [{id: 3, type: 'comment'}]});\n  env.store.push('comment', { id: 3 });\n\n  var asyncRecords = Ember.RSVP.hash({\n    user: env.store.find('user', 1),\n    comment: env.store.find('comment', 3)\n  });\n\n  asyncRecords.then(async(function(records) {\n    records.messages = records.user.get('messages');\n    return Ember.RSVP.hash(records);\n  })).then(async(function(records) {\n    equal(records.messages.get('length'), 1, \"The user has 1 message\");\n\n    var removedObject = records.messages.popObject();\n\n    equal(removedObject, records.comment, \"The message is correctly removed\");\n    equal(records.messages.get('length'), 0, \"The user does not have any messages\");\n  }));\n});\n\ntest(\"When a record is created on the client, its hasMany arrays should be in a loaded state\", function() {\n  expect(3);\n\n  var post;\n\n  Ember.run(function() {\n    post = env.store.createRecord('post');\n  });\n\n  ok(get(post, 'isLoaded'), \"The post should have isLoaded flag\");\n\n  var comments = get(post, 'comments');\n\n  equal(get(comments, 'length'), 0, \"The comments should be an empty array\");\n\n  ok(get(comments, 'isLoaded'), \"The comments should have isLoaded flag\");\n\n});\n\ntest(\"When a record is created on the client, its async hasMany arrays should be in a loaded state\", function() {\n  expect(4);\n\n  Post.reopen({\n    comments: DS.hasMany('comment', { async: true })\n  });\n\n  var post;\n\n  Ember.run(function() {\n    post = env.store.createRecord('post');\n  });\n\n  ok(get(post, 'isLoaded'), \"The post should have isLoaded flag\");\n\n  get(post, 'comments').then(function(comments) {\n    ok(true, \"Comments array successfully resolves\");\n    equal(get(comments, 'length'), 0, \"The comments should be an empty array\");\n    ok(get(comments, 'isLoaded'), \"The comments should have isLoaded flag\");\n  });\n\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/has_many_test");