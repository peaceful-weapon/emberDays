minispade.register('ember-data/~tests/integration/adapter/store_adapter_test', "(function() {/**\n This is an integration test that tests the communication between a store\n and its adapter.\n\n Typically, when a method is invoked on the store, it calls a related\n method on its adapter. The adapter notifies the store that it has\n completed the assigned task, either synchronously or asynchronously,\n by calling a method on the store.\n\n These tests ensure that the proper methods get called, and, if applicable,\n the given record orrecord arrayay changes state appropriately.\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar Person, Dog, env, store, adapter;\n\nmodule(\"integration/adapter/store_adapter - DS.Store and DS.Adapter integration test\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    Dog = DS.Model.extend({\n      name: DS.attr('string')\n    });\n\n    env = setupStore({ person: Person, dog: Dog });\n    store = env.store;\n    adapter = env.adapter;\n  },\n\n  teardown: function() {\n    env.container.destroy();\n  }\n});\n\ntest(\"Records loaded multiple times and retrieved in recordArray are ready to send state events\", function() {\n  adapter.findQuery = function(store, type, query, recordArray) {\n    return Ember.RSVP.resolve([{\n      id: 1,\n      name: \"Mickael Ram√≠rez\"\n    }, {\n      id: 2,\n      name: \"Johny Fontana\"\n    }]);\n  };\n\n  store.findQuery('person', {q: 'bla'}).then(async(function(people) {\n    var people2 = store.findQuery('person', { q: 'bla2' });\n\n    return Ember.RSVP.hash({ people: people, people2: people2 });\n  })).then(async(function(results) {\n    equal(results.people2.get('length'), 2, 'return the elements' );\n    ok( results.people2.get('isLoaded'), 'array is loaded' );\n\n    var person = results.people.objectAt(0);\n    ok(person.get('isLoaded'), 'record is loaded');\n\n    // delete record will not throw exception\n    person.deleteRecord();\n  }));\n\n});\n\ntest(\"by default, createRecords calls createRecord once per record\", function() {\n  var count = 1;\n\n  adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 1) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 2) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not have invoked more than 2 times\");\n    }\n\n    var hash = get(record, 'data');\n    hash.id = count;\n    hash.updatedAt = \"now\";\n\n    count++;\n    return Ember.RSVP.resolve(hash);\n  };\n\n  var tom = store.createRecord('person', { name: \"Tom Dale\" });\n  var yehuda = store.createRecord('person', { name: \"Yehuda Katz\" });\n\n  Ember.RSVP.hash({ tom: tom.save(), yehuda: yehuda.save() }).then(async(function(records) {\n    tom = records.tom;\n    yehuda = records.yehuda;\n\n    asyncEqual(tom, store.find('person', 1), \"Once an ID is in, find returns the same object\");\n    asyncEqual(yehuda, store.find('person', 2), \"Once an ID is in, find returns the same object\");\n    equal(get(tom, 'updatedAt'), \"now\", \"The new information is received\");\n    equal(get(yehuda, 'updatedAt'), \"now\", \"The new information is received\");\n  }));\n});\n\ntest(\"by default, updateRecords calls updateRecord once per record\", function() {\n  var count = 0;\n\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    equal(record.get('isSaving'), true, \"record is saving\");\n\n    return Ember.RSVP.resolve();\n  };\n\n  store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  store.push('person', { id: 2, name: \"Brohuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    set(tom, \"name\", \"Tom Dale\");\n    set(yehuda, \"name\", \"Yehuda Katz\");\n\n    return Ember.RSVP.hash({ tom: tom.save(), yehuda: yehuda.save() });\n  })).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    equal(tom.get('isSaving'), false, \"record is no longer saving\");\n    equal(tom.get('isLoaded'), true, \"record is loaded\");\n\n    equal(yehuda.get('isSaving'), false, \"record is no longer saving\");\n    equal(yehuda.get('isLoaded'), true, \"record is loaded\");\n  }));\n});\n\ntest(\"calling store.didSaveRecord can provide an optional hash\", function() {\n  var count = 0;\n\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    count++;\n    if (count === 1) {\n      equal(get(record, 'name'), \"Tom Dale\");\n      return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", updatedAt: \"now\" });\n    } else if (count === 2) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n      return Ember.RSVP.resolve({ id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" });\n    } else {\n      ok(false, \"should not get here\");\n    }\n  };\n\n  store.push('person', { id: 1, name: \"Braaaahm Dale\" });\n  store.push('person', { id: 2, name: \"Brohuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    set(tom, \"name\", \"Tom Dale\");\n    set(yehuda, \"name\", \"Yehuda Katz\");\n\n    return Ember.RSVP.hash({ tom: tom.save(), yehuda: yehuda.save() });\n  })).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    equal(get(tom, 'isDirty'), false, \"the record should not be dirty\");\n    equal(get(tom, 'updatedAt'), \"now\", \"the hash was updated\");\n\n    equal(get(yehuda, 'isDirty'), false, \"the record should not be dirty\");\n    equal(get(yehuda, 'updatedAt'), \"now!\", \"the hash was updated\");\n  }));\n});\n\ntest(\"by default, deleteRecord calls deleteRecord once per record\", function() {\n  expect(4);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    return Ember.RSVP.resolve();\n  };\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n  store.push('person', { id: 2, name: \"Yehuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    tom.deleteRecord();\n    yehuda.deleteRecord();\n\n    tom.save();\n    yehuda.save();\n  }));\n});\n\ntest(\"by default, destroyRecord calls deleteRecord once per record without requiring .save\", function() {\n  expect(4);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    return Ember.RSVP.resolve();\n  };\n\n  store.push('person', { id: 1, name: \"Tom Dale\" });\n  store.push('person', { id: 2, name: \"Yehuda Katz\" });\n\n  Ember.RSVP.hash({ tom: store.find('person', 1), yehuda: store.find('person', 2) }).then(async(function(records) {\n    var tom = records.tom, yehuda = records.yehuda;\n\n    tom.destroyRecord();\n    yehuda.destroyRecord();\n  }));\n});\n\ntest(\"if an existing model is edited then deleted, deleteRecord is called on the adapter\", function() {\n  expect(5);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    count++;\n    equal(get(record, 'id'), 'deleted-record', \"should pass correct record to deleteRecord\");\n    equal(count, 1, \"should only call deleteRecord method of adapter once\");\n\n    return Ember.RSVP.resolve();\n  };\n\n  adapter.updateRecord = function() {\n    ok(false, \"should not have called updateRecord method of adapter\");\n  };\n\n  // Load data for a record into the store.\n  store.push('person', { id: 'deleted-record', name: \"Tom Dale\" });\n\n  // Retrieve that loaded record and edit it so it becomes dirty\n  store.find('person', 'deleted-record').then(async(function(tom) {\n    tom.set('name', \"Tom Mothereffin' Dale\");\n\n    equal(get(tom, 'isDirty'), true, \"precond - record should be dirty after editing\");\n\n    tom.deleteRecord();\n    return tom.save();\n  })).then(async(function(tom) {\n    equal(get(tom, 'isDirty'), false, \"record should not be dirty\");\n    equal(get(tom, 'isDeleted'), true, \"record should be considered deleted\");\n  }));\n});\n\ntest(\"if a deleted record errors, it enters the error state\", function() {\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    if (count++ === 0) {\n      return Ember.RSVP.reject();\n    } else {\n      return Ember.RSVP.resolve();\n    }\n  };\n\n  store.push('person', { id: 'deleted-record', name: \"Tom Dale\" });\n\n  var tom;\n\n  store.find('person', 'deleted-record').then(async(function(person) {\n    tom = person;\n    person.deleteRecord();\n    return person.save();\n  })).then(null, async(function() {\n    equal(tom.get('isError'), true, \"Tom is now errored\");\n\n    // this time it succeeds\n    return tom.save();\n  })).then(async(function() {\n    equal(tom.get('isError'), false, \"Tom is not errored anymore\");\n  }));\n});\n\ntest(\"if a created record is marked as invalid by the server, it enters an error state\", function() {\n  adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (get(record, 'name').indexOf('Bro') === -1) {\n      return Ember.RSVP.reject(new DS.InvalidError({ name: ['common... name requires a \"bro\"'] }));\n    } else {\n      return Ember.RSVP.resolve();\n    }\n  };\n\n  var yehuda = store.createRecord('person', { id: 1, name: \"Yehuda Katz\" });\n\n  // Wrap this in an Ember.run so that all chained async behavior is set up\n  // before flushing any scheduled behavior.\n  Ember.run(function() {\n    yehuda.save().then(null, async(function(error) {\n      equal(get(yehuda, 'isValid'), false, \"the record is invalid\");\n      ok(get(yehuda, 'errors.name'), \"The errors.name property exists\");\n\n      set(yehuda, 'updatedAt', true);\n      equal(get(yehuda, 'isValid'), false, \"the record is still invalid\");\n\n      // This tests that we handle undefined values without blowing up\n      var errors = get(yehuda, 'errors');\n      set(errors, 'other_bound_property', undefined);\n      set(yehuda, 'errors', errors);\n      set(yehuda, 'name', \"Brohuda Brokatz\");\n\n      equal(get(yehuda, 'isValid'), true, \"the record is no longer invalid after changing\");\n      equal(get(yehuda, 'isDirty'), true, \"the record has outstanding changes\");\n\n      equal(get(yehuda, 'isNew'), true, \"precond - record is still new\");\n\n      return yehuda.save();\n    })).then(async(function(person) {\n      strictEqual(person, yehuda, \"The promise resolves with the saved record\");\n\n      equal(get(yehuda, 'isValid'), true, \"record remains valid after committing\");\n      equal(get(yehuda, 'isNew'), false, \"record is no longer new\");\n    }));\n  });\n});\n\ntest(\"if a created record is marked as erred by the server, it enters an error state\", function() {\n  adapter.createRecord = function(store, type, record) {\n    return Ember.RSVP.reject();\n  };\n\n  Ember.run(function() {\n    var person = store.createRecord('person', { id: 1, name: \"John Doe\" });\n\n    person.save().then(null, async(function() {\n      ok(get(person, 'isError'), \"the record is in the error state\");\n    }));\n  });\n});\n\ntest(\"if an updated record is marked as invalid by the server, it enters an error state\", function() {\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (get(record, 'name').indexOf('Bro') === -1) {\n      return Ember.RSVP.reject(new DS.InvalidError({ name: ['common... name requires a \"bro\"'] }));\n    } else {\n      return Ember.RSVP.resolve();\n    }\n  };\n\n  var yehuda = store.push('person', { id: 1, name: \"Brohuda Brokatz\" });\n\n  Ember.run(function() {\n    store.find('person', 1).then(async(function(person) {\n      equal(person, yehuda, \"The same object is passed through\");\n\n      equal(get(yehuda, 'isValid'), true, \"precond - the record is valid\");\n      set(yehuda, 'name', \"Yehuda Katz\");\n      equal(get(yehuda, 'isValid'), true, \"precond - the record is still valid as far as we know\");\n\n      equal(get(yehuda, 'isDirty'), true, \"the record is dirty\");\n\n      return yehuda.save();\n    })).then(null, async(function(reason) {\n      equal(get(yehuda, 'isDirty'), true, \"the record is still dirty\");\n      equal(get(yehuda, 'isValid'), false, \"the record is invalid\");\n\n      set(yehuda, 'updatedAt', true);\n      equal(get(yehuda, 'isValid'), false, \"the record is still invalid\");\n\n      set(yehuda, 'name', \"Brohuda Brokatz\");\n      equal(get(yehuda, 'isValid'), true, \"the record is no longer invalid after changing\");\n      equal(get(yehuda, 'isDirty'), true, \"the record has outstanding changes\");\n\n      return yehuda.save();\n    })).then(async(function(yehuda) {\n      equal(get(yehuda, 'isValid'), true, \"record remains valid after committing\");\n      equal(get(yehuda, 'isDirty'), false, \"record is no longer new\");\n    }));\n  });\n});\n\ntest(\"if a updated record is marked as erred by the server, it enters an error state\", function() {\n  adapter.updateRecord = function(store, type, record) {\n    return Ember.RSVP.reject();\n  };\n\n  var person = store.push(Person, { id: 1, name: \"John Doe\" });\n\n  store.find('person', 1).then(async(function(record) {\n    equal(record, person, \"The person was resolved\");\n    person.set('name', \"Jonathan Doe\");\n    return person.save();\n  })).then(null, async(function(reason) {\n    ok(get(person, 'isError'), \"the record is in the error state\");\n  }));\n});\n\ntest(\"can be created after the DS.Store\", function() {\n  expect(1);\n\n  adapter.find = function(store, type) {\n    equal(type, Person, \"the type is correct\");\n    return Ember.RSVP.resolve({ id: 1 });\n  };\n\n  store.find('person', 1);\n});\n\ntest(\"the filter method can optionally take a server query as well\", function() {\n  adapter.findQuery = function(store, type, query, array) {\n    return Ember.RSVP.resolve([\n      { id: 1, name: \"Yehuda Katz\" },\n      { id: 2, name: \"Tom Dale\" }\n    ]);\n  };\n\n  var asyncFilter = store.filter('person', { page: 1 }, function(data) {\n    return data.get('name') === \"Tom Dale\";\n  });\n\n  var loadedFilter;\n\n  asyncFilter.then(async(function(filter) {\n    loadedFilter = filter;\n    return store.find('person', 2);\n  })).then(async(function(tom) {\n    equal(get(loadedFilter, 'length'), 1, \"The filter has an item in it\");\n    deepEqual(loadedFilter.toArray(), [ tom ], \"The filter has a single entry in it\");\n  }));\n});\n\ntest(\"relationships returned via `commit` do not trigger additional findManys\", function() {\n  Person.reopen({\n    dogs: DS.hasMany()\n  });\n\n  store.push('dog', { id: 1, name: \"Scruffy\" });\n\n  adapter.find = function(store, type, id) {\n    return Ember.RSVP.resolve({ id: 1, name: \"Tom Dale\", dogs: [1] });\n  };\n\n  adapter.updateRecord = function(store, type, record) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n      store.push('person', { id: 1, name: \"Tom Dale\", dogs: [1, 2] });\n      store.push('dog', { id: 2, name: \"Scruffles\" });\n      resolve({ id: 1, name: \"Scruffy\" });\n    });\n  };\n\n  adapter.findMany = function(store, type, ids) {\n    ok(false, \"Should not get here\");\n  };\n\n  store.find('person', 1).then(async(function(person) {\n    return Ember.RSVP.hash({ tom: person, dog: store.find('dog', 1) });\n  })).then(async(function(records) {\n    records.tom.get('dogs');\n    return records.dog.save();\n  })).then(async(function(tom) {\n    ok(true, \"Tom was saved\");\n  }));\n});\n\ntest(\"relationships don't get reset if the links is the same\", function() {\n  Person.reopen({\n    dogs: DS.hasMany({ async: true })\n  });\n\n  var count = 0;\n\n  adapter.findHasMany = function() {\n    ok(count++ === 0, \"findHasMany is only called once\");\n\n    return Ember.RSVP.resolve([{ id: 1, name: \"Scruffy\" }]);\n  };\n\n  store.push('person', { id: 1, name: \"Tom Dale\", links: { dogs: \"/dogs\" } });\n\n  var tom, dogs;\n\n  store.find('person', 1).then(async(function(person) {\n    tom = person;\n    dogs = tom.get('dogs');\n    return dogs;\n  })).then(async(function(dogs) {\n    equal(dogs.get('length'), 1, \"The dogs are loaded\");\n    store.push('person', { id: 1, name: \"Tom Dale\", links: { dogs: \"/dogs\" } });\n    return tom.get('dogs');\n  })).then(async(function(dogs) {\n    equal(dogs.get('length'), 1, \"The same dogs are loaded\");\n  }));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/store_adapter_test");