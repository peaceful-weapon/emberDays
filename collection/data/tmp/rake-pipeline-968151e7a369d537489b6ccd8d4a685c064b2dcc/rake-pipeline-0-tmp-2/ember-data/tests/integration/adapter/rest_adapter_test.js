minispade.register('ember-data/~tests/integration/adapter/rest_adapter_test', "(function() {var env, store, adapter, Post, Person, Comment, SuperUser;\nvar originalAjax, passedUrl, passedVerb, passedHash;\n\nmodule(\"integration/adapter/rest_adapter - REST Adapter\", {\n  setup: function() {\n    Post = DS.Model.extend({\n      name: DS.attr(\"string\")\n    });\n\n    Post.toString = function() {\n      return \"Post\";\n    };\n\n    Comment = DS.Model.extend({\n      name: DS.attr(\"string\")\n    });\n\n    SuperUser = DS.Model.extend();\n\n    env = setupStore({\n      post: Post,\n      comment: Comment,\n      superUser: SuperUser,\n      adapter: DS.RESTAdapter\n    });\n\n    store = env.store;\n    adapter = env.adapter;\n\n    passedUrl = passedVerb = passedHash = null;\n  }\n});\n\nfunction ajaxResponse(value) {\n  adapter.ajax = function(url, verb, hash) {\n    passedUrl = url;\n    passedVerb = verb;\n    passedHash = hash;\n\n    return Ember.RSVP.resolve(value);\n  };\n}\n\ntest(\"find - basic payload\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\n\ntest(\"find - basic payload (with legacy singular name)\", function() {\n  ajaxResponse({ post: { id: 1, name: \"Rails is omakase\" } });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\ntest(\"find - payload with sideloaded records of the same type\", function() {\n  var count = 0;\n\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n\n    var post2 = store.getById('post', 2);\n    equal(post2.get('id'), \"2\");\n    equal(post2.get('name'), \"The Parley Letter\");\n  }));\n});\n\ntest(\"find - payload with sideloaded records of a different type\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('id'), \"1\");\n    equal(comment.get('name'), \"FIRST\");\n  }));\n});\n\ntest(\"find - payload with an serializer-specified primary key\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_'\n  }));\n\n  ajaxResponse({ posts: [{ \"_ID_\": 1, name: \"Rails is omakase\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\n\ntest(\"find - payload with a serializer-specified attribute mapping\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    attrs: {\n      'name': '_NAME_'\n    }\n  }));\n\n  ajaxResponse({ posts: [{ id: 1, _NAME_: \"Rails is omakase\" }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash, undefined);\n\n    equal(post.get('id'), \"1\");\n    equal(post.get('name'), \"Rails is omakase\");\n  }));\n});\n\ntest(\"create - an empty payload is a basic success if an id was specified\", function() {\n  ajaxResponse();\n\n  var post = store.createRecord('post', { id: \"some-uuid\", name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { id: \"some-uuid\", name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"The Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"create - a payload with a new ID and data applies the updates\", function() {\n  ajaxResponse({ posts: [{ id: \"1\", name: \"Dat Parley Letter\" }] });\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('id'), \"1\", \"the post has the updated ID\");\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"create - a payload with a new ID and data applies the updates (with legacy singular name)\", function() {\n  ajaxResponse({ post: { id: \"1\", name: \"Dat Parley Letter\" } });\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('id'), \"1\", \"the post has the updated ID\");\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"create - findMany doesn't overwrite owner\", function() {\n  ajaxResponse({ comment: { id: \"1\", name: \"Dat Parley Letter\", post: 1 } });\n\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n  Comment.reopen({ post: DS.belongsTo('post') });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [] });\n  var post = store.getById('post', 1);\n\n  var comment = store.createRecord('comment', { name: \"The Parley Letter\" });\n  post.get('comments').pushObject(comment);\n\n  equal(comment.get('post'), post, \"the post has been set correctly\");\n\n  comment.save().then(async(function(comment) {\n    equal(comment.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(comment.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n    equal(comment.get('post'), post, \"the post is still set\");\n  }));\n});\n\ntest(\"create - a serializer's primary key and attributes are consulted when building the payload\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_id_',\n\n    attrs: {\n      name: '_name_'\n    }\n  }));\n\n  ajaxResponse();\n\n  var post = store.createRecord('post', { id: \"some-uuid\", name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    deepEqual(passedHash.data, { post: { _id_: 'some-uuid', '_name_': \"The Parley Letter\" } });\n  }));\n});\n\ntest(\"create - a serializer's attributes are consulted when building the payload if no id is pre-defined\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primarykey: '_id_',\n\n    attrs: {\n      name: '_name_'\n    }\n  }));\n\n  ajaxResponse();\n\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    deepEqual(passedHash.data, { post: { '_name_': \"The Parley Letter\" } });\n  }));\n});\n\ntest(\"create - a record on the many side of a hasMany relationship should update relationships when data is sideloaded\", function() {\n  expect(3);\n\n  ajaxResponse({\n    posts: [{\n      id: \"1\",\n      name: \"Rails is omakase\",\n      comments: [1,2]\n    }],\n    comments: [{\n      id: \"1\",\n      name: \"Dat Parley Letter\",\n      post: 1\n    },{\n      id: \"2\",\n      name: \"Another Comment\",\n      post: 1\n    }]\n    // My API is returning a comment:{} as well as a comments:[{...},...]\n    //, comment: {\n    //   id: \"2\",\n    //   name: \"Another Comment\",\n    //   post: 1\n    // }\n  });\n\n  Post.reopen({ comments: DS.hasMany('comment') });\n  Comment.reopen({ post: DS.belongsTo('post') });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [1] });\n  store.push('comment', { id: 1, name: \"Dat Parlay Letter\", post: 1 });\n\n  var post = store.getById('post', 1);\n  var commentCount = post.get('comments.length');\n  equal(commentCount, 1, \"the post starts life with a comment\");\n\n  var comment = store.createRecord('comment', { name: \"Another Comment\", post: post });\n\n  comment.save().then(async(function(comment) {\n    equal(comment.get('post'), post, \"the comment is related to the post\");\n  }));\n\n  post.reload().then(async(function(post) {\n    equal(post.get('comments.length'), 2, \"Post comment count has been updated\");\n  }));\n});\n\ntest(\"update - an empty payload is a basic success\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse();\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"The Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"update - a payload with updates applies the updates\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ posts: [{ id: 1, name: \"Dat Parley Letter\" }] });\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"update - a payload with updates applies the updates (with legacy singular name)\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ post: { id: 1, name: \"Dat Parley Letter\" } });\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n  }));\n});\n\ntest(\"update - a payload with sideloaded updates pushes the updates\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Dat Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n  var post = store.createRecord('post', { name: \"The Parley Letter\" });\n\n  post.save().then(async(function(post) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"POST\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('id'), \"1\", \"the post has the updated ID\");\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('name'), \"FIRST\", \"The comment was sideloaded\");\n  }));\n});\n\n\ntest(\"update - a payload with sideloaded updates pushes the updates\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ posts: [{ id: 1, name: \"Dat Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"PUT\");\n    deepEqual(passedHash.data, { post: { name: \"The Parley Letter\" } });\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('name'), \"Dat Parley Letter\", \"the post was updated\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('name'), \"FIRST\", \"The comment was sideloaded\");\n  }));\n});\n\ntest(\"update - a serializer's primary key and attributes are consulted when building the payload\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_id_',\n\n    attrs: {\n      name: '_name_'\n    }\n  }));\n\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n  ajaxResponse();\n\n  store.find('post', 1).then(async(function(post) {\n    post.set('name', \"The Parley Letter\");\n    return post.save();\n  })).then(async(function(post) {\n    deepEqual(passedHash.data, { post: { '_name_': \"The Parley Letter\" } });\n  }));\n});\n\ntest(\"delete - an empty payload is a basic success\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse();\n\n    post.deleteRecord();\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"DELETE\");\n    equal(passedHash, undefined);\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('isDeleted'), true, \"the post is now deleted\");\n  }));\n});\n\ntest(\"delete - a payload with sideloaded updates pushes the updates\", function() {\n  store.push('post', { id: 1, name: \"Rails is omakase\" });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }] });\n\n    post.deleteRecord();\n    return post.save();\n  })).then(async(function(post) {\n    equal(passedUrl, \"/posts/1\");\n    equal(passedVerb, \"DELETE\");\n    equal(passedHash, undefined);\n\n    equal(post.get('isDirty'), false, \"the post isn't dirty anymore\");\n    equal(post.get('isDeleted'), true, \"the post is now deleted\");\n\n    var comment = store.getById('comment', 1);\n    equal(comment.get('name'), \"FIRST\", \"The comment was sideloaded\");\n  }));\n});\n\ntest(\"findAll - returning an array populates the array\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.findAll('post').then(async(function(posts) {\n    equal(passedUrl, \"/posts\");\n    equal(passedVerb, \"GET\");\n    equal(passedHash.data, undefined);\n\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findAll - returning sideloaded data loads the data\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n  store.findAll('post').then(async(function(posts) {\n    var comment = store.getById('comment', 1);\n\n    deepEqual(comment.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n  }));\n});\n\ntest(\"findAll - data is normalized through custom serializers\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  ajaxResponse({ posts: [{ _ID_: 1, _NAME_: \"Rails is omakase\" }, { _ID_: 2, _NAME_: \"The Parley Letter\" }] });\n\n  store.findAll('post').then(async(function(posts) {\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findAll - since token is passed to the adapter\", function() {\n  ajaxResponse({ meta: { since: 'later'}, posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.metaForType('post', { since: 'now' });\n\n  store.findAll('post').then(async(function(posts) {\n    equal(passedUrl, '/posts');\n    equal(passedVerb, 'GET');\n    equal(store.typeMapFor(Post).metadata.since, 'later');\n    deepEqual(passedHash.data, { since: 'now' });\n  }));\n});\n\ntest(\"metadata is accessible\", function() {\n  ajaxResponse({ meta: { offset: 5 }, posts: [{id: 1, name: \"Rails is very expensive sushi\"}] });\n\n  store.findAll('post').then(async(function(posts) {\n    equal(store.metadataFor('post').offset, 5, \"Metadata can be accessed with metadataFor.\");\n  }));\n});\n\ntest(\"findQuery - payload 'meta' is accessible on the record array\", function() {\n  ajaxResponse({ meta: { offset: 5 }, posts: [{id: 1, name: \"Rails is very expensive sushi\"}] });\n\n  store.findQuery('post', { page: 2 }).then(async(function(posts) {\n    equal(posts.get('meta.offset'), 5, \"Reponse metadata can be accessed with recordArray.meta\");\n  }));\n});\n\ntest(\"findQuery - returning an array populates the array\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }] });\n\n  store.findQuery('post', { page: 1 }).then(async(function(posts) {\n    equal(passedUrl, '/posts');\n    equal(passedVerb, 'GET');\n    deepEqual(passedHash.data, { page: 1 });\n\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findQuery - returning sideloaded data loads the data\", function() {\n  ajaxResponse({ posts: [{ id: 1, name: \"Rails is omakase\" }, { id: 2, name: \"The Parley Letter\" }], comments: [{ id: 1, name: \"FIRST\" }] });\n\n  store.findQuery('post', { page: 1 }).then(async(function(posts) {\n    var comment = store.getById('comment', 1);\n\n    deepEqual(comment.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n  }));\n});\n\ntest(\"findQuery - data is normalized through custom serializers\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  ajaxResponse({ posts: [{ _ID_: 1, _NAME_: \"Rails is omakase\" }, { _ID_: 2, _NAME_: \"The Parley Letter\" }] });\n\n  store.findQuery('post', { page: 1 }).then(async(function(posts) {\n    var post1 = store.getById('post', 1),\n        post2 = store.getById('post', 2);\n\n    deepEqual(post1.getProperties('id', 'name'), { id: \"1\", name: \"Rails is omakase\" }, \"Post 1 is loaded\");\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" }, \"Post 2 is loaded\");\n\n    equal(posts.get('length'), 2, \"The posts are in the array\");\n    equal(posts.get('isLoaded'), true, \"The RecordArray is loaded\");\n    deepEqual(posts.toArray(), [ post1, post2 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findMany - returning an array populates the array\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [ 1, 2, 3 ] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findMany - returning sideloaded data loads the data\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [ 1, 2, 3 ] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }, { id: 4, name: \"Unrelated comment\" }], posts: [{ id: 2, name: \"The Parley Letter\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3),\n        comment4 = store.getById('comment', 4),\n        post2    = store.getById('post', 2);\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n\n    deepEqual(comment4.getProperties('id', 'name'), { id: \"4\", name: \"Unrelated comment\" });\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" });\n  }));\n});\n\ntest(\"findMany - a custom serializer is used if present\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  env.container.register('serializer:comment', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", comments: [ 1, 2, 3 ] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ _ID_: 1, _NAME_: \"FIRST\" }, { _ID_: 2, _NAME_: \"Rails is unagi\" }, { _ID_: 3, _NAME_: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findHasMany - returning an array populates the array\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", links: { comments: '/posts/1/comments' } });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    equal(passedUrl, '/posts/1/comments');\n    equal(passedVerb, 'GET');\n    equal(passedHash, undefined);\n\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest(\"findMany - returning sideloaded data loads the data\", function() {\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", links: { comments: '/posts/1/comments' } });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1, name: \"FIRST\" }, { id: 2, name: \"Rails is unagi\" }, { id: 3, name: \"What is omakase?\" }], posts: [{ id: 2, name: \"The Parley Letter\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3),\n        post2    = store.getById('post', 2);\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n\n    deepEqual(post2.getProperties('id', 'name'), { id: \"2\", name: \"The Parley Letter\" });\n  }));\n});\n\ntest(\"findMany - a custom serializer is used if present\", function() {\n  env.container.register('serializer:post', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  env.container.register('serializer:comment', DS.RESTSerializer.extend({\n    primaryKey: '_ID_',\n    attrs: { name: '_NAME_' }\n  }));\n\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n\n  store.push('post', { id: 1, name: \"Rails is omakase\", links: { comments: '/posts/1/comments' } });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ _ID_: 1, _NAME_: \"FIRST\" }, { _ID_: 2, _NAME_: \"Rails is unagi\" }, { _ID_: 3, _NAME_: \"What is omakase?\" }] });\n    return post.get('comments');\n  })).then(async(function(comments) {\n    var comment1 = store.getById('comment', 1),\n        comment2 = store.getById('comment', 2),\n        comment3 = store.getById('comment', 3);\n\n    deepEqual(comment1.getProperties('id', 'name'), { id: \"1\", name: \"FIRST\" });\n    deepEqual(comment2.getProperties('id', 'name'), { id: \"2\", name: \"Rails is unagi\" });\n    deepEqual(comment3.getProperties('id', 'name'), { id: \"3\", name: \"What is omakase?\" });\n\n    deepEqual(comments.toArray(), [ comment1, comment2, comment3 ], \"The correct records are in the array\");\n  }));\n});\n\ntest('buildURL - with host and namespace', function() {\n  adapter.setProperties({\n    host: 'http://example.com',\n    namespace: 'api/v1'\n  });\n\n  ajaxResponse({ posts: [{ id: 1 }] });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(passedUrl, \"http://example.com/api/v1/posts/1\");\n  }));\n});\n\ntest('buildURL - with relative paths in links', function() {\n  adapter.setProperties({\n    host: 'http://example.com',\n    namespace: 'api/v1'\n  });\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n  Comment.reopen({ post: DS.belongsTo('post') });\n\n  ajaxResponse({ posts: [{ id: 1, links: { comments: 'comments' } }] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1 }] });\n    return post.get('comments');\n  })).then(async(function (comments) {\n    equal(passedUrl, \"http://example.com/api/v1/posts/1/comments\");\n  }));\n});\n\ntest('buildURL - with absolute paths in links', function() {\n  adapter.setProperties({\n    host: 'http://example.com',\n    namespace: 'api/v1'\n  });\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n  Comment.reopen({ post: DS.belongsTo('post') });\n\n  ajaxResponse({ posts: [{ id: 1, links: { comments: '/api/v1/posts/1/comments' } }] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1 }] });\n    return post.get('comments');\n  })).then(async(function (comments) {\n    equal(passedUrl, \"http://example.com/api/v1/posts/1/comments\");\n  }));\n});\n\ntest('buildURL - with full URLs in links', function() {\n  adapter.setProperties({\n    host: 'http://example.com',\n    namespace: 'api/v1'\n  });\n  Post.reopen({ comments: DS.hasMany('comment', { async: true }) });\n  Comment.reopen({ post: DS.belongsTo('post') });\n\n  ajaxResponse({ posts: [{ id: 1, links: { comments: 'http://example.com/api/v1/posts/1/comments' } }] });\n\n  store.find('post', 1).then(async(function(post) {\n    ajaxResponse({ comments: [{ id: 1 }] });\n    return post.get('comments');\n  })).then(async(function (comments) {\n    equal(passedUrl, \"http://example.com/api/v1/posts/1/comments\");\n  }));\n});\n\ntest('buildURL - with camelized names', function() {\n  adapter.setProperties({\n    pathForType: function(type) {\n      var decamelized = Ember.String.decamelize(type);\n      return Ember.String.pluralize(decamelized);\n    }\n  });\n\n  ajaxResponse({ superUsers: [{ id: 1 }] });\n\n  store.find('superUser', 1).then(async(function(post) {\n    equal(passedUrl, \"/super_users/1\");\n  }));\n});\n\ntest('normalizeKey - to set up _ids and _id', function() {\n  env.container.register('serializer:application', DS.RESTSerializer.extend({\n    keyForAttribute: function(attr) {\n      //if (kind === 'hasMany') {\n        //key = key.replace(/_ids$/, '');\n        //key = Ember.String.pluralize(key);\n      //} else if (kind === 'belongsTo') {\n        //key = key.replace(/_id$/, '');\n      //}\n\n      return Ember.String.underscore(attr);\n    },\n\n    keyForBelongsTo: function(belongsTo) {\n    },\n\n    keyForRelationship: function(rel, kind) {\n      if (kind === 'belongsTo') {\n        var underscored = Ember.String.underscore(rel);\n        return underscored + '_id';\n      } else {\n        var singular = Ember.String.singularize(rel);\n        return Ember.String.underscore(singular) + '_ids';\n      }\n    }\n  }));\n\n  env.container.register('model:post', DS.Model.extend({\n    name: DS.attr(),\n    authorName: DS.attr(),\n    author: DS.belongsTo('user'),\n    comments: DS.hasMany('comment')\n  }));\n\n  env.container.register('model:user', DS.Model.extend({\n    createdAt: DS.attr(),\n    name: DS.attr()\n  }));\n\n  env.container.register('model:comment', DS.Model.extend({\n    body: DS.attr()\n  }));\n\n  ajaxResponse({\n    posts: [{\n      id: \"1\",\n      name: \"Rails is omakase\",\n      author_name: \"@d2h\",\n      author_id: \"1\",\n      comment_ids: [ \"1\", \"2\" ]\n    }],\n\n    users: [{\n      id: \"1\",\n      name: \"D2H\"\n    }],\n\n    comments: [{\n      id: \"1\",\n      body: \"Rails is unagi\"\n    }, {\n      id: \"2\",\n      body: \"What is omakase?\"\n    }]\n  });\n\n  store.find('post', 1).then(async(function(post) {\n    equal(post.get('authorName'), \"@d2h\");\n    equal(post.get('author.name'), \"D2H\");\n    deepEqual(post.get('comments').mapBy('body'), [\"Rails is unagi\", \"What is omakase?\"]);\n  }));\n});\n\n//test(\"creating a record with a 422 error marks the records as invalid\", function(){\n  //expect(1);\n\n  //var mockXHR = {\n    //status:       422,\n    //responseText: JSON.stringify({ errors: { name: [\"can't be blank\"]} })\n  //};\n\n  //jQuery.ajax = function(hash) {\n    //hash.error.call(hash.context, mockXHR, \"Unprocessable Entity\");\n  //};\n\n  //var post = store.createRecord(Post, { name: \"\" });\n\n  //post.on(\"becameInvalid\", function() {\n    //ok(true, \"becameInvalid is called\");\n  //});\n\n  //post.on(\"becameError\", function() {\n    //ok(false, \"becameError is not called\");\n  //});\n\n  //post.save();\n//});\n\n//test(\"changing A=>null=>A should clean up the record\", function() {\n  //var store = DS.Store.create({\n    //adapter: DS.RESTAdapter\n  //});\n  //var Kidney = DS.Model.extend();\n  //var Person = DS.Model.extend();\n\n  //Kidney.reopen({\n    //person: DS.belongsTo(Person)\n  //});\n  //Kidney.toString = function() { return \"Kidney\"; };\n\n  //Person.reopen({\n    //name: DS.attr('string'),\n    //kidneys: DS.hasMany(Kidney)\n  //});\n  //Person.toString = function() { return \"Person\"; };\n\n  //store.load(Person, { id: 1, kidneys: [1, 2] });\n  //store.load(Kidney, { id: 1, person: 1 });\n  //store.load(Kidney, { id: 2, person: 1 });\n\n  //var person = store.find(Person, 1);\n  //var kidney1 = store.find(Kidney, 1);\n  //var kidney2 = store.find(Kidney, 2);\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney1, kidney2], \"precond - person should have both kidneys\");\n  //equal(kidney1.get('person'), person, \"precond - first kidney should be in the person\");\n\n  //person.get('kidneys').removeObject(kidney1);\n\n  //ok(person.get('isDirty'), \"precond - person should be dirty after operation\");\n  //ok(kidney1.get('isDirty'), \"precond - first kidney should be dirty after operation\");\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney2], \"precond - person should have only the second kidney\");\n  //equal(kidney1.get('person'), null, \"precond - first kidney should be on the operating table\");\n\n  //person.get('kidneys').addObject(kidney1);\n\n  //ok(!person.get('isDirty'), \"person should be clean after restoration\");\n  //ok(!kidney1.get('isDirty'), \"first kidney should be clean after restoration\");\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney2, kidney1], \"person should have both kidneys again\");\n  //equal(kidney1.get('person'), person, \"first kidney should be in the person again\");\n//});\n\n//test(\"changing A=>B=>A should clean up the record\", function() {\n  //var store = DS.Store.create({\n    //adapter: DS.RESTAdapter\n  //});\n  //var Kidney = DS.Model.extend();\n  //var Person = DS.Model.extend();\n\n  //Kidney.reopen({\n    //person: DS.belongsTo(Person)\n  //});\n  //Kidney.toString = function() { return \"Kidney\"; };\n\n  //Person.reopen({\n    //name: DS.attr('string'),\n    //kidneys: DS.hasMany(Kidney)\n  //});\n  //Person.toString = function() { return \"Person\"; };\n\n  //store.load(Person, { person: { id: 1, name: \"John Doe\", kidneys: [1, 2] }});\n  //store.load(Person, { person: { id: 2, name: \"Jane Doe\", kidneys: [3]} });\n  //store.load(Kidney, { kidney: { id: 1, person_id: 1 } });\n  //store.load(Kidney, { kidney: { id: 2, person_id: 1 } });\n  //store.load(Kidney, { kidney: { id: 3, person_id: 2 } });\n\n  //var john = store.find(Person, 1);\n  //var jane = store.find(Person, 2);\n  //var kidney1 = store.find(Kidney, 1);\n  //var kidney2 = store.find(Kidney, 2);\n  //var kidney3 = store.find(Kidney, 3);\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1, kidney2], \"precond - john should have the first two kidneys\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3], \"precond - jane should have the third kidney\");\n  //equal(kidney2.get('person'), john, \"precond - second kidney should be in john\");\n\n  //kidney2.set('person', jane);\n\n  //ok(john.get('isDirty'), \"precond - john should be dirty after operation\");\n  //ok(jane.get('isDirty'), \"precond - jane should be dirty after operation\");\n  //ok(kidney2.get('isDirty'), \"precond - second kidney should be dirty after operation\");\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1], \"precond - john should have only the first kidney\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3, kidney2], \"precond - jane should have the other two kidneys\");\n  //equal(kidney2.get('person'), jane, \"precond - second kidney should be in jane\");\n\n  //kidney2.set('person', john);\n\n  //ok(!john.get('isDirty'), \"john should be clean after restoration\");\n  //ok(!jane.get('isDirty'), \"jane should be clean after restoration\");\n  //ok(!kidney2.get('isDirty'), \"second kidney should be clean after restoration\");\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1, kidney2], \"john should have the first two kidneys again\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3], \"jane should have the third kidney again\");\n  //equal(kidney2.get('person'), john, \"second kidney should be in john again\");\n//});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/rest_adapter_test");