minispade.register('ember-data/~tests/integration/adapter/fixture_adapter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar env, Person, Phone, App;\n\nmodule(\"integration/adapter/fixture_adapter - DS.FixtureAdapter\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n\n      height: DS.attr('number'),\n\n      phones: DS.hasMany('phone', { async: true })\n    });\n\n    Phone = DS.Model.extend({\n      person: DS.belongsTo('person')\n    });\n\n    env = setupStore({ person: Person, phone: Phone, adapter: DS.FixtureAdapter });\n    env.adapter.simulateRemoteResponse = true;\n\n    // Enable setTimeout.\n    Ember.testing = false;\n\n    Person.FIXTURES = [];\n    Phone.FIXTURES = [];\n  },\n  teardown: function() {\n    Ember.testing = true;\n\n    env.container.destroy();\n  }\n});\n\ntest(\"should load data for a type asynchronously when it is requested\", function() {\n  Person.FIXTURES = [{\n    id: 'wycats',\n    firstName: \"Yehuda\",\n    lastName: \"Katz\",\n\n    height: 65\n  },\n\n  {\n    id: 'ebryn',\n    firstName: \"Erik\",\n    lastName: \"Brynjolffsosysdfon\",\n\n    height: 70,\n    phones: [1, 2]\n  }];\n\n  Phone.FIXTURES = [{\n    id: 1,\n    person: 'ebryn'\n  }, {\n    id: 2,\n    person: 'ebryn'\n  }];\n\n  env.store.find('person', 'ebryn').then(async(function(ebryn) {\n    equal(get(ebryn, 'isLoaded'), true, \"data loads asynchronously\");\n    equal(get(ebryn, 'height'), 70, \"data from fixtures is loaded correctly\");\n\n    return Ember.RSVP.hash({ ebryn: ebryn, wycats: env.store.find('person', 'wycats') });\n  }, 1000)).then(async(function(records) {\n    equal(get(records.wycats, 'isLoaded'), true, \"subsequent requests for records are returned asynchronously\");\n    equal(get(records.wycats, 'height'), 65, \"subsequent requested records contain correct information\");\n\n    return get(records.ebryn, 'phones');\n  }, 1000)).then(async(function(phones) {\n    equal(get(phones, 'length'), 2, \"relationships from fixtures is loaded correctly\");\n  }, 1000));\n});\n\ntest(\"should load data asynchronously at the end of the runloop when simulateRemoteResponse is false\", function() {\n  Person.FIXTURES = [{\n    id: 'wycats',\n    firstName: \"Yehuda\"\n  }];\n\n  env.adapter.simulateRemoteResponse = false;\n\n  var wycats;\n\n  Ember.run(function() {\n    env.store.find('person', 'wycats').then(function(person) {\n      wycats = person;\n    });\n  });\n\n  ok(get(wycats, 'isLoaded'), 'isLoaded is true after runloop finishes');\n  equal(get(wycats, 'firstName'), 'Yehuda', 'record properties are defined after runloop finishes');\n});\n\ntest(\"should create record asynchronously when it is committed\", function() {\n  equal(Person.FIXTURES.length, 0, \"Fixtures is empty\");\n\n  var paul = env.store.createRecord('person', {firstName: 'Paul', lastName: 'Chavard', height: 70});\n\n  paul.on('didCreate', async(function() {\n    equal(get(paul, 'isNew'), false, \"data loads asynchronously\");\n    equal(get(paul, 'isDirty'), false, \"data loads asynchronously\");\n    equal(get(paul, 'height'), 70, \"data from fixtures is saved correctly\");\n\n    equal(Person.FIXTURES.length, 1, \"Record added to FIXTURES\");\n\n    var fixture = Person.FIXTURES[0];\n\n    ok(typeof fixture.id === 'string', \"The fixture has an ID generated for it\");\n    equal(fixture.firstName, 'Paul');\n    equal(fixture.lastName, 'Chavard');\n    equal(fixture.height, 70);\n  }));\n\n  paul.save();\n});\n\ntest(\"should update record asynchronously when it is committed\", function() {\n  equal(Person.FIXTURES.length, 0, \"Fixtures is empty\");\n\n  var paul = env.store.push('person', { id: 1, firstName: 'Paul', lastName: 'Chavard', height: 70});\n\n  paul.set('height', 80);\n\n  paul.on('didUpdate', async(function() {\n    equal(get(paul, 'isDirty'), false, \"data loads asynchronously\");\n    equal(get(paul, 'height'), 80, \"data from fixtures is saved correctly\");\n\n    equal(Person.FIXTURES.length, 1, \"Record FIXTURES updated\");\n\n    var fixture = Person.FIXTURES[0];\n\n    equal(fixture.firstName, 'Paul');\n    equal(fixture.lastName, 'Chavard');\n    equal(fixture.height, 80);\n  }, 1000));\n\n  paul.save();\n});\n\ntest(\"should delete record asynchronously when it is committed\", function() {\n  stop();\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n\n  equal(Person.FIXTURES.length, 0, \"Fixtures empty\");\n\n  var paul = env.store.push('person', { id: 'paul', firstName: 'Paul', lastName: 'Chavard', height: 70 });\n\n  paul.deleteRecord();\n\n  paul.on('didDelete', function() {\n    clearTimeout(timer);\n    start();\n\n    equal(get(paul, 'isDeleted'), true, \"data deleted asynchronously\");\n    equal(get(paul, 'isDirty'), false, \"data deleted asynchronously\");\n\n    equal(Person.FIXTURES.length, 0, \"Record removed from FIXTURES\");\n  });\n\n  paul.save();\n});\n\ntest(\"should follow isUpdating semantics\", function() {\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n\n  stop();\n\n  Person.FIXTURES = [{\n    id: \"twinturbo\",\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  var result = env.store.findAll('person');\n\n  result.then(function(all) {\n    clearTimeout(timer);\n    start();\n    equal(get(all, 'isUpdating'), false, \"isUpdating is set when it shouldn't be\");\n  });\n});\n\ntest(\"should coerce integer ids into string\", function() {\n  Person.FIXTURES = [{\n    id: 1,\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  env.store.find('person', 1).then(async(function(result) {\n    strictEqual(get(result, 'id'), \"1\", \"should load integer model id as string\");\n  }));\n});\n\ntest(\"should coerce belongsTo ids into string\", function() {\n  Person.FIXTURES = [{\n    id: 1,\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n\n    phones: [1]\n  }];\n\n  Phone.FIXTURES = [{\n    id: 1,\n    person: 1\n  }];\n\n  env.store.find('phone', 1).then(async(function(result) {\n    var person = get(result, 'person');\n    person.one('didLoad', async(function() {\n      strictEqual(get(result, 'person.id'), \"1\", \"should load integer belongsTo id as string\");\n      strictEqual(get(result, 'person.firstName'), \"Adam\", \"resolved relationship with an integer belongsTo id\");\n    }));\n  }));\n});\n\ntest(\"only coerce belongsTo ids to string if id is defined and not null\", function() {\n  Person.FIXTURES = [];\n\n  Phone.FIXTURES = [{\n    id: 1\n  }];\n\n  env.store.find('phone', 1).then(async(function(phone) {\n    equal(phone.get('person'), null);\n  }));\n});\n\ntest(\"should throw if ids are not defined in the FIXTURES\", function() {\n  Person.FIXTURES = [{\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  raises(function(){\n    env.store.find('person', 1);\n  }, /the id property must be defined as a number or string for fixture/);\n\n  Person.FIXTURES = [{\n    id: 0\n  }];\n\n  env.store.find('person', 0).then(async(function() {\n    ok(true, \"0 is an acceptable ID, so no exception was thrown\");\n  }), function() {\n    ok(false, \"should not get here\");\n  });\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapter/fixture_adapter_test");